# Load packages
suppressPackageStartupMessages({
  library(scales)
  library(future)
    library(progress)
    library(progressr)
  library(ChIPseeker)
  library(readr)
  library(data.table)
  library(purrr)
  library(stringr)
  library(tibble)
  library(ArchR)
library(dplyr)
library(future)
library(future.apply)
library(progressr)
library(broom)
library(Matrix)
library(tidyverse)
library(data.table)
library(GenomicRanges)
library(TxDb.Hsapiens.UCSC.hg38.knownGene)
library(org.Hs.eg.db)
library(patchwork)  
  library(DESeq2)
  library(tidyverse)
  library(parallel)
  library(ComplexHeatmap)
  library(tidytext)
  library(RColorBrewer)
  library(circlize)
  library(GenomicRanges)
  library(viridis)
  library(janitor)
  library(data.table)
  library(R.utils)
  library(ComplexHeatmap)
  library(circlize)  
  library(viridis)
  library(dplyr)
  library(annotatr)
  library(TxDb.Hsapiens.UCSC.hg38.knownGene)
  library(tidyr)
  library(AnnotationHub)
  library(GenomicRanges)
  library(GenomicFeatures)
  library(EnhancedVolcano)
  library(biomaRt)
  library(pathview)
  library(ggplot2)
  library(stringr)
  library(GSVA)
  library(forcats)
  library(enrichplot)
  library(clusterProfiler)
  library(org.Hs.eg.db)
  library(ReactomePA)      
  library(DOSE) 
  library(AUCell)
  library(scCustomize)
  library(gridExtra)
  library(GENIE3)
  library(ggpubr)
  library(fgsea)
  library(msigdbr)
  library(patchwork)
  library(qs)
  library(RColorBrewer)
  library(UpSetR)
  library(doRNG)
  library(sctransform)
  library(rlang)
  library(cli)
  library(ggraph)
  library(ggthemes)
  library(tidyverse)
  library(magrittr)
  library(tictoc)
  library(rstatix)
  library(cowplot)
  library(harmony)
  library(DESeq2)
  library(rhdf5)
  library(Seurat)
  library(SeuratObject)
  options(Seurat.object.assay.version = "v5")
  options(future.globals.maxSize = 1e9)
})

python_output_dir <- "/Users/rileymullins/Documents/Acute_v_Chronic_Data"
output_dir <- file.path(python_output_dir, "STEP_4_output_deseq2_peak_analysis_ACUTE_ONLY")
bulk_rna_dir <- file.path(output_dir, "wherry_bulk_rna_seq_analysis")
bulk_atac_dir <- file.path(output_dir, "wherry_bulk_atac_analysis")
bzip_results_outdir <- file.path(bulk_atac_dir, "bZIP_combined_linear_regression")
dir.create(bzip_results_outdir, recursive = TRUE, showWarnings = FALSE)

scdir <- file.path(bulk_atac_dir, "hdWGCNA_combined_linear_regression")


figdir <-"~/Documents/CC_Figs_08092025/figs"


#### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### ####
#### Figure 2 ####
#### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### ####
# Number of peaks per group
ac <- read.csv("~/Documents/Acute_v_Chronic_Data/STEP_4_output_deseq2_peak_analysis_ACUTE_ONLY/HOMER_annotations_COMBINED_all_Group_vs_Control_results.csv")
ch <- read.csv("~/Documents/Acute_v_Chronic_Data/STEP_4_output_deseq2_peak_analysis_CHRONIC_ONLY/HOMER_annotations_COMBINED_all_Group_vs_Control_results.csv")

# Combine
comb <- rbind(ac,ch)

# Count number of rows for each unique group
counts <- comb %>% group_by(group) %>% dplyr::count()

# Recode the names 
counts <- counts %>%
  dplyr::mutate(
    TF = recode(
      group,
      "SOX4_Acute" = "SOX4 Acute",
      "SOX4_Chronic" = "SOX4 Chronic",
      "TCF7_Acute" = "TCF7 Acute",
      "TCF7_Chronic" = "TCF7 Chronic",
      "TOX_Acute" = "TOX Acute",
      "TOX_Chronic" = "TOX Chronic",
      "TOX2_Acute" = "TOX2 Acute",
      "TOX2_Chronic" = "TOX2 Chronic",
      "RBPJ_Acute" = "RBPJ Acute"
    )
  ) %>%
  dplyr::mutate(
    # Set the factor levels 
    TF = factor(TF, levels = c("TOX Acute", "TOX2 Acute","TCF7 Acute", "SOX4 Acute", "RBPJ Acute",
                               "TOX Chronic",  "TOX2 Chronic", "TCF7 Chronic",  "SOX4 Chronic")
                )
  )

# Set colors
acute_color <- "#0E8746"
chronic_color <-  "#00007F"
color_mapping <- setNames(
  ifelse(grepl("Acute", levels(counts$TF)), acute_color, chronic_color),
  levels(counts$TF)
)

# Plot
p <- ggplot(counts, aes(x = TF, y = n, fill = TF)) +
  geom_bar(stat = "identity", color = "black", width = 0.5, linewidth=0.25) +
  scale_fill_manual(values = color_mapping) +
  labs(
    x = NULL,
    y = "Peak Count"
  ) + 
  theme_minimal(base_size = 8) +
  theme(
    text = element_text(color = "black"),
    plot.title = element_text(hjust = 0.5, face = "bold"),
    axis.title.y = element_text(face = "bold"),
    axis.text = element_text(face = "bold", color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
    axis.line = element_line(color = "black", size = 0.5),
    axis.ticks = element_line(color = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.background = element_blank(),
    plot.background = element_blank(),
    legend.position = "none"
  )+scale_y_continuous(expand = c(0, 0))


print(p)

# Save as .png
ggsave(file = file.path(figdir,"Total_Peaks_per_Condition_Plot.png"), plot = p, width = 3, height = 2.5, bg="white",dpi = 300)

# Save as .pdf
ggsave(file = file.path(figdir,"Total_Peaks_per_Condition_Plot.pdf"), plot = p, width = 3, height =2.5)




# Plot motif enrichment
homer_ac <-"~/Documents/Acute_v_Chronic_Data/STEP_4_output_deseq2_peak_analysis_ACUTE_ONLY/HOMER/HOMER_motif_analysis/HOMER_Motif_Output"
homer_ch <-"~/Documents/Acute_v_Chronic_Data/STEP_4_output_deseq2_peak_analysis_CHRONIC_ONLY/HOMER/HOMER_motif_analysis/HOMER_Motif_Output"

#  Process and Plot HOMER Motif Results
# Define directory and read/clean HOMER outputs 
motif_result_files <- list.files(
  c(homer_ac,homer_ch),
  pattern    = "knownResults.txt",
  recursive  = TRUE,
  full.names = TRUE
)
# Load and clean motif results properly
motif_results <- purrr::map_dfr(motif_result_files, function(file) {
  read_tsv(file, comment = "#", show_col_types = FALSE, col_names = TRUE) %>%
    janitor::clean_names() %>%
    dplyr::mutate(group_name = basename(dirname(file)) %>%
                       str_remove("_motif_output$") %>%
                       str_trim())
})

# Parse x6 column to get %target and %background
motif_results <- motif_results %>%
  dplyr::mutate(
    x6_split = str_split(x6, pattern = "\t"),
    pct_target = map_dbl(x6_split, ~ as.numeric(str_remove(.[2], "%"))),
    pct_background = map_dbl(x6_split, ~ as.numeric(str_remove(.[4], "%")))
  ) %>%
  select(-x6, -x6_split)

# Groups of interest
groups_of_interest <- c("TCF7", "SOX4", "RBPJ")

# Filter groups and motif names exact matches
motif_filtered <- motif_results %>%
  filter(str_detect(group_name, paste(groups_of_interest, collapse = "|"))) %>%
  dplyr::mutate(motif_name_clean = toupper(str_extract(motif_name, "^[^/]+"))) %>%
  filter(
    (str_detect(group_name, "TCF7") & motif_name_clean == "TCF7(HMG)") |
    (str_detect(group_name, "SOX4") & motif_name_clean == "SOX4(HMG)") |
    (str_detect(group_name, "RBPJ") & motif_name_clean == "RBPJ1(?)")
  ) %>%
  filter(-log_p_value > 30)  # keep strong enrichment

# Make sure group_name is a factor for color mapping
motif_filtered <- motif_filtered %>%
  dplyr::mutate(group_name = factor(group_name))


# Recode
motif_filtered <- motif_filtered %>%
  dplyr::mutate(
    group_name = recode(
      group_name,
      "SOX4_Acute" = "SOX4 Acute",
      "SOX4_Chronic" = "SOX4 Chronic",
      "TCF7_Acute" = "TCF7 Acute",
      "TCF7_Chronic" = "TCF7 Chronic",
      "RBPJ_Acute" = "RBPJ Acute"
    )
  ) %>%
  dplyr::mutate(
    # Set the factor levels 
    group_name = factor(group_name, levels =c("TCF7 Acute", "TCF7 Chronic", "SOX4 Acute", "SOX4 Chronic", "RBPJ Acute" )
                )
  )
# Set colors for Acute vs Chronic
color_mapping <- setNames(
  ifelse(grepl("Acute", levels(motif_filtered$group_name)), acute_color, chronic_color),
  levels(motif_filtered$group_name)
)


# Plot with one bar per group (x = group_name)
motif_plot <- ggplot(motif_filtered, aes(x = group_name, y = -log_p_value, fill = group_name)) +
  geom_col(color = "black", linewidth = 0.25, width = 0.5, show.legend = F) +
  scale_fill_manual(values = color_mapping) +
  labs(x = NULL, y = "-log10(P) of TF's Motif", fill = "Group") +
  theme_minimal(base_size = 8) +
  theme(
    text = element_text(color = "black"),
    plot.title = element_text(hjust = 0.5, face = "bold"),
    axis.title.y = element_text(face = "bold"),
    axis.text = element_text(face = "bold", color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
    axis.line = element_line(color = "black", size = 0.5),
    axis.ticks = element_line(color = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.background = element_blank(),
    plot.background = element_blank(),
    legend.position = "none"
  )+scale_y_continuous(expand = c(0, 0))

print(motif_plot)


# Save 
ggsave(file.path(figdir, "homer_motifs.png"), motif_plot, width = 3, height = 2.25, dpi = 300, bg = "white")
ggsave(file.path(figdir, "homer_motifs.pdf"), motif_plot, width = 3, height = 2.25)


# Pathway analysis

# Filter to protein-coding promoter peaks only
comb_filtered <- comb %>%
  filter(
    gene_type == "protein-coding",
    str_detect(annotation, regex("promoter", ignore_case = TRUE))
  )

# Extract unique entrez ids for each group
genes_per_group <- comb_filtered %>%
  group_by(group) %>%
  dplyr::summarise(entrez_id = list(unique(entrez_id))) %>%
  # convert to named list
  { setNames(.$entrez_id, .$group) }


# Run  pathway analysis
go_list <- list()
for (i in seq_along(genes_per_group)){
go_list[[i]] <- enrichGO(gene = genes_per_group[[i]], OrgDb = org.Hs.eg.db, ont = "BP", pAdjustMethod = "BH", pvalueCutoff = 0.05,qvalueCutoff = 0.05, readable = TRUE)
names(go_list)[[i]] <- names(genes_per_group)[[i]]
go_list[[i]]@result$group <- names(genes_per_group)[[i]]
}

# Combine all result data.frames into one
all_res <- do.call(rbind, lapply(go_list, function(x) x@result))


# Helper function to compute Jaccard similarity between two character vectors
jaccard_sim <- function(a, b) {
  length(intersect(a, b)) / length(union(a, b))
}

select_top_unique_pathways <- function(df, top_n = 3, max_jaccard = 0.5) {
  selected <- list()
  selected_indices <- integer()
  
  # Extract gene sets as list of character vectors
  gene_lists <- str_split(df$geneID, pattern = "/|,|;") # adjust separator if needed
  
  for (i in seq_len(nrow(df))) {
    current_genes <- gene_lists[[i]]
    if (length(selected) == 0) {
      # Always accept the first (best) pathway
      selected <- list(current_genes)
      selected_indices <- c(selected_indices, i)
    } else {
      # Check similarity to all previously selected pathways
      sims <- map_dbl(selected, ~ jaccard_sim(current_genes, .x))
      if (all(sims < max_jaccard)) {
        selected <- append(selected, list(current_genes))
        selected_indices <- c(selected_indices, i)
      }
    }
    if (length(selected) == top_n) break
  }
  
  df[selected_indices, ]
}

# Usage per group
top_clusters <- all_res %>%
  filter(qvalue < 0.05) %>%
  group_by(group) %>%
  arrange(qvalue) %>%
  group_split() %>%
  map_dfr(~ select_top_unique_pathways(.x, top_n = 3, max_jaccard = 0.8))%>%
  dplyr::mutate(neg_log_fdr = -log10(qvalue))

# Top clusters wihtout jaccard
top_clusters <- all_res %>%
  filter(qvalue < 0.05) %>%
  group_by(group) %>%
  arrange(qvalue) %>%
  slice_head(n=3) %>%
  dplyr::mutate(neg_log_fdr = -log10(qvalue))


# Determine the global order of 'Description' based on GeneRatio_numeric and cluster
unique(top_clusters$Description)
desc_recode <- c(
  "telomere organization" = "Telomere",
  "protein localization to chromosome" = "Chromosome Localization",
  "lymphocyte differentiation" = "Lymphocyte Diff",
  "nucleosome organization" = "Nucleosome Organization",
  "alpha-beta T cell activation" = "T Cell Act.",
  "epigenetic regulation of gene expression" = "Epigenetic Reg.",
  "positive regulation of interleukin-12 production" = "IL12 Production",
  "natural killer cell mediated immunity" = "NK Immunity",
  "regulation of hemopoiesis" = "Hemopoiesis",
  "lymphocyte proliferation" = "Lymphocyte Proliferation",
  "positive regulation of cell activation" = "Cell Act.",
  "CD4-positive, alpha-beta T cell activation" = "CD4 T Cell Act.",
  "regulation of mononuclear cell migration" = "Migration",
  "myeloid cell differentiation" = "Myeloid Diff.",
  "mononuclear cell proliferation" = "Mononuclear Prolif.",
  "regulation of lymphocyte differentiation" = "Reg. of Lymphocyte Diff.",
  "nucleosome assembly" = "Nucleosome Assembly",
 "regulation of alpha-beta T cell activation" = "Reg. of αβ T Cell Act.",
  "homeostasis of number of cells" = "Cell Cycle",
  "T cell differentiation" = "T Cell Diff",
  "positive regulation of leukocyte activation" = "Leukocyte Act.",
  "T cell selection" = "T Cell Selection",
  "regulation of T cell activation" = "Reg. of T Cell Act.",
 "regulation of T cell differentiation" = "Reg. of T Cell Diff.",
  "positive regulation of mononuclear cell proliferation" = "Proliferation",
  "CD4-positive, alpha-beta T cell differentiation involved in immune response" = "CD4 T Cell Diff."
)

top_clusters <- top_clusters %>%
  dplyr::mutate(
    Description = recode(as.character(Description), !!!desc_recode)
  )


# Set group factor levels (TF acute first, then chronic)
top_clusters$group <- factor(top_clusters$group, levels = c(
  "TOX_Acute", "TOX_Chronic",
  "TOX2_Acute", "TOX2_Chronic",
  "TCF7_Acute", "TCF7_Chronic",
  "SOX4_Acute", "SOX4_Chronic",
  "RBPJ_Acute"
))



# Order Description within each group by descending Count
top_clusters <- top_clusters %>%
  group_by(group) %>%
  arrange(desc(Count), .by_group = TRUE) %>%
  dplyr::mutate(Description = factor(Description, levels = unique(Description))) %>%
  ungroup()


# Create the dot plot using ggplot
dot_plot <- ggplot(top_clusters, aes(x = group, y = Description, size = Count, color = neg_log_fdr)) +
  # Main colored points
  geom_point(alpha = 1) +
  # Outline that automatically uses the same size scale
  geom_point(shape = 1, colour = "black", stroke = 0.3, show.legend = FALSE) +
  
  scale_color_viridis(
    name = "-log10(FDR)",
    option = "B",
    direction = 1,
    limits = c(0, 10),
    oob = scales::squish
  ) +
  scale_size_continuous(
    name = "Gene Count",
    range = c(1, 4),
    limits = c(0, 40)
  ) +
  labs(title = NULL, x = NULL, y = NULL) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 8, face="bold", color = "black"),
    axis.text.y = element_text(size = 8, color = "black"),
    axis.ticks = element_line(color = "black"),
    plot.title = element_text(hjust = 0.5, size = 8, face = "bold", color = "black"),
    legend.position = "right",
    legend.margin = margin(0, 0, 0, 0),
    legend.key.height = unit(0.4, "cm"),
    legend.spacing.x = unit(0.2, "cm"),
    legend.key.width = unit(0.3, "cm"),
    legend.title = element_text(hjust = 0.5, size = 8, face = "bold", color = "black"),
    legend.text = element_text(hjust = 0.5, size = 8, color = "black"),
    panel.border = element_rect(color = "black", fill = NA, size = 1),
    strip.text = element_text(size = 8, color = "black"),
    strip.background = element_blank()
  ) +
  scale_y_discrete(limits = rev)

# Print the plot
print(dot_plot)

# Save as .png
ggsave(file=file.path(figdir,"Top_Unique_GO_Promoter_Enriched_Terms_HOMER_Promoter_Protein_Coding.png"), plot = dot_plot, width = 4, height = 3.5, bg="white",dpi = 300)

# Save as .pdf
ggsave(file=file.path(figdir,"Top_Unique_GO_Promoter_Enriched_Terms_HOMER_Promoter_Protein_Coding.pdf"), plot = dot_plot, width = 4, height = 3.4)


# Genomic distributions plot
# Simplify annotation categories 
comb <- comb %>%
  dplyr::mutate(
    annot_type_simple = case_when(
      # Promoter = ±1kb
      abs(distance_to_tss) <= 1000 ~ "Promoter",

      # Nearby TSS = between 1kb and 10kb
      abs(distance_to_tss) > 1000 & abs(distance_to_tss) <= 5000 ~ "+/-5kb of TSS",

      grepl("3' UTR", annotation, ignore.case = TRUE)  ~ "3' UTR",
      grepl("5' UTR", annotation, ignore.case = TRUE)  ~ "5' UTR",
      grepl("exon", annotation, ignore.case = TRUE)    ~ "Exon",
      grepl("intron", annotation, ignore.case = TRUE)  ~ "Intron",
      grepl("Intergenic", annotation, ignore.case = TRUE) ~ "Intergenic",
      grepl("non-coding", annotation, ignore.case = TRUE) ~ "Intergenic",
      grepl("TTS", annotation, ignore.case = TRUE)     ~ "TTS",
      TRUE ~ "Other"
    )
  )

# Calculate counts and proportions per group and annotation type
prop_df <- comb %>%
  group_by(group, annot_type_simple) %>%
  dplyr::summarise(count = n(), .groups = "drop") %>%
  group_by(group) %>%
  dplyr::mutate(proportion = count / sum(count)) %>%
  ungroup()

unique(prop_df$annot_type_simple)

 
# Factor ordering for consistent plotting
label_order <- c(
  "Promoter","+/-5kb of TSS", "5' UTR", "Exon",
  "Intron", "3' UTR", "TTS", "Intergenic"
)

group_order <- c(
  "TOX_Acute", "TOX_Chronic",
  "TOX2_Acute", "TOX2_Chronic",
  "TCF7_Acute", "TCF7_Chronic",
  "SOX4_Acute", "SOX4_Chronic",
  "RBPJ_Acute"
)

prop_df <- prop_df %>%
  dplyr::mutate(
    annot_type_simple = factor(annot_type_simple, levels = rev(label_order)),
    group = factor(group, levels = rev(group_order))
  )

# Generate palette and create plot
plot_colors <- RColorBrewer::brewer.pal(
  n    = length(levels(prop_df$annot_type_simple)),
  name = "Paired"
)

# Make plot
genomic_distribution_plot <- ggplot(
  prop_df,
  aes(x = group, y = proportion, fill = annot_type_simple)
) +
  geom_col(color = "black", linewidth = 0.25, width = 0.5) +
  scale_fill_manual(
    values = plot_colors,
    name = "Genomic Region",
    drop = FALSE,
    guide = guide_legend(reverse = TRUE)
  ) +
  coord_flip() +
  labs(x = NULL, y = "Proportion of Peaks") +
  theme_minimal(base_size = 8) +
  theme(
    axis.title.x = element_blank(),
    axis.title.y = element_text(color = "black", size = 8,face="bold"),
    axis.text.x = element_text(color = "black", size = 8,face="bold"),
    axis.text.y = element_text(color = "black", size = 8,face="bold"),
    legend.title = element_text(color = "black", size = 7, face = "bold"),
    legend.text = element_text(color = "black", size = 7),
    panel.grid.minor = element_blank(),
      legend.position = "right",
  legend.margin = margin(0, 0, 0, 0),
  plot.margin = margin(0, 0, 0, 0),
  legend.key.height = unit(0.3, "cm"),
  legend.spacing.x = unit(0.2, "cm"),
  legend.key.width = unit(0.3, "cm"),

    panel.grid.major = element_blank(),
    
    axis.line = element_line(color = "black", size = 0.5),
    plot.title = element_text(hjust = 0.5, face = "bold", color = "black", size = 8)
  )
genomic_distribution_plot
# Save the plot
ggsave(
  file.path(figdir, "HOMER_genomic_annotation_proportions_plot_accent.png"),
  genomic_distribution_plot, width = 3.25, height = 2.5, dpi = 300, bg = "white"
)
ggsave(
  file.path(figdir, "HOMER_genomic_annotation_proportions_plot_accent.pdf"),
  genomic_distribution_plot, width =3.25, height = 2.5, bg = "white"
)







library(GenomicRanges)
library(dplyr)
library(ggplot2)
library(tidyr)


all_peaks_clean_plot <- all_peaks_clean %>% filter(group %in% c(
      "SOX4_Acute"  ,
      "SOX4_Chronic",
      "TCF7_Acute"  ,
      "TCF7_Chronic",
      "TOX_Acute"   ,
      "TOX_Chronic" ,
      "TOX2_Acute"  ,
      "TOX2_Chronic" ,
      "RBPJ_Acute"  )
      )


      
## ---- Overlap logic ----
# Convert to GRanges
peaks_gr <- GRanges(
  seqnames = all_peaks_clean_plot$chr,
  ranges   = IRanges(start = all_peaks_clean_plot$start,
                     end   = all_peaks_clean_plot$end),
  peak_id  = all_peaks_clean_plot$peak_id,
  group    = all_peaks_clean_plot$group
)

acr_gr <- GRanges(
  seqnames = acr_annot$Chr,
  ranges   = IRanges(start = acr_annot$Start,
                     end   = acr_annot$End),
  acr_id   = acr_annot$acr_id
)

# Find overlaps with maxgap=1000
hits <- findOverlaps(peaks_gr, acr_gr, maxgap = 1000)

# Flag overlaps
all_peaks_clean_plot$overlaps_acr <- FALSE
all_peaks_clean_plot$overlaps_acr[queryHits(hits)] <- TRUE


## ---- Summarize per group ----
counts_overlap <- all_peaks_clean_plot %>%
  group_by(group) %>%
  summarise(
    overlap = sum(overlaps_acr),
    nonoverlap = n() - sum(overlaps_acr),
    .groups = "drop"
  ) %>%
  mutate(
    TF = recode(
      group,
      "SOX4_Acute"   = "SOX4 Acute",
      "SOX4_Chronic" = "SOX4 Chronic",
      "TCF7_Acute"   = "TCF7 Acute",
      "TCF7_Chronic" = "TCF7 Chronic",
      "TOX_Acute"    = "TOX Acute",
      "TOX_Chronic"  = "TOX Chronic",
      "TOX2_Acute"   = "TOX2 Acute",
      "TOX2_Chronic" = "TOX2 Chronic",
      "RBPJ_Acute"   = "RBPJ Acute"
    ),
    TF = factor(TF, levels = c("TOX Acute", "TOX2 Acute","TCF7 Acute", "SOX4 Acute", "RBPJ Acute",
                               "TOX Chronic",  "TOX2 Chronic", "TCF7 Chronic",  "SOX4 Chronic"))
  )

# Reshape for ggplot stacked bars
counts_long <- counts_overlap %>%
  pivot_longer(cols = c("overlap", "nonoverlap"),
               names_to = "status", values_to = "count")

## ---- Colors ----
acute_color   <- "#0E8746"
chronic_color <- "#00007F"
base_colors <- setNames(
  ifelse(grepl("Acute", levels(counts_overlap$TF)), acute_color, chronic_color),
  levels(counts_overlap$TF)
)

# Overlap = full color, nonoverlap = lighter shade
color_mapping <- c()
for (tf in names(base_colors)) {
  base_col <- base_colors[tf]
  color_mapping[paste0(tf, "_overlap")]    <- base_col
  color_mapping[paste0(tf, "_nonoverlap")] <- scales::alpha(base_col, 0.2)
}

## ---- Plot ----
p <- ggplot(counts_long, aes(x = TF, y = count,
                             fill = interaction(TF, status, sep = "_"))) +
  geom_bar(stat = "identity", color = "black", width = 0.5, linewidth = 0.25) +
  scale_fill_manual(values = color_mapping, guide = "none") +
  labs(x = NULL, y = "Peak Count") + 
  theme_minimal(base_size = 8) +
  theme(
    text = element_text(color = "black"),
    axis.title.y = element_text(face = "bold"),
    axis.text = element_text(face = "bold", color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
    axis.line = element_line(color = "black", size = 0.5),
    axis.ticks = element_line(color = "black"),
    panel.grid = element_blank(),
    panel.background = element_blank(),
    plot.background = element_blank(),
    legend.position = "none"
  ) +
  scale_y_continuous(expand = c(0, 0))

print(p)


ggsave(file = file.path(figdir,"Peaks_per_Condition_Color_by_Peak_Overlap_with_ATACseq.png"), plot = p,
       width = 3, height = 2.5, bg="white", dpi = 300)
ggsave(file = file.path(figdir,"Peaks_per_Condition_Color_by_Peak_Overlap_with_ATACseq.pdf"), plot = p,
       width = 3, height = 2.5)






## ---- Log2fc violin Plot ----

# all_peaks_clean_plot$log2fc  (log2 fold-change above background)
# all_peaks_clean_plot$norm_inserts (normalized SRT insertions per peak)

# Recode group names for plotting
all_peaks_clean_plot <- all_peaks_clean_plot %>%
  mutate(
    TF = recode(
      group,
      "SOX4_Acute"   = "SOX4 Acute",
      "SOX4_Chronic" = "SOX4 Chronic",
      "TCF7_Acute"   = "TCF7 Acute",
      "TCF7_Chronic" = "TCF7 Chronic",
      "TOX_Acute"    = "TOX Acute",
      "TOX_Chronic"  = "TOX Chronic",
      "TOX2_Acute"   = "TOX2 Acute",
      "TOX2_Chronic" = "TOX2 Chronic",
      "RBPJ_Acute"   = "RBPJ Acute"
    ),
    TF = factor(TF, levels = c(
      "TOX Acute", "TOX2 Acute", "TCF7 Acute", "SOX4 Acute", "RBPJ Acute",
      "TOX Chronic", "TOX2 Chronic", "TCF7 Chronic", "SOX4 Chronic"))
  )





p <- ggplot(all_peaks_clean_plot, aes(x = TF, y = log2FoldChange, fill = TF)) +
  geom_violin(alpha = 1, trim = TRUE, color = "black",linewidth = 0.25) +  # fill inside, no outline
  scale_fill_manual(values = c(
    "TOX Acute"   = "#0E8746", "TOX2 Acute"   = "#0E8746", "TCF7 Acute"   = "#0E8746",
    "SOX4 Acute"  = "#0E8746", "RBPJ Acute"   = "#0E8746",
    "TOX Chronic" = "#00007F", "TOX2 Chronic" = "#00007F", "TCF7 Chronic" = "#00007F",
    "SOX4 Chronic"= "#00007F"
  )) +
  scale_y_continuous(
    limits = c(0, 8),
    breaks = 0:8,
    labels = 0:8,
    expand = c(0, 0)
  ) +
  labs(x = NULL, y = "Log2FC of SRT Insertions Relative to\nUnfused HyPBase Background Control") +
  theme_minimal(base_size = 9) +
  theme(
    text = element_text(color = "black"),
    axis.title.y = element_text(face = "bold"),
    axis.text = element_text(face = "bold", color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
    axis.line = element_line(color = "black", size = 0.5),
    axis.ticks = element_line(color = "black"),
    panel.grid.major.y = element_blank(),
    panel.grid.major.x = element_blank(),
    panel.grid.minor = element_blank(),
    panel.background = element_blank(),
    plot.background = element_blank(),
    legend.position = "none"
  )

print(p)


ggsave(file.path(figdir, "Violin_log2FC_vs_SRT.png"), plot = p,
       width = 4, height = 3, bg="white", dpi = 300)

ggsave(file.path(figdir, "Violin_log2FC_vs_SRT.pdf"), plot = p,
       width = 4, height = 3, device = cairo_pdf)







## ---- Permutation test of binding in +-/5kb of TSS range ----

#   Define promoters ±5kb
txdb <- TxDb.Hsapiens.UCSC.hg38.knownGene

prom5kb <- promoters(txdb, upstream = 5000, downstream = 5000)
prom5kb <- reduce(prom5kb)  # merge overlapping intervals

# keep only standard chromosomes (auto + X, Y, M)
prom5kb <- keepStandardChromosomes(prom5kb, pruning.mode = "coarse")

#  Convert peaks dataframe to GRanges
peaks_all <- makeGRangesFromDataFrame(
  comb,                   # df with chr/start/end/group
  seqnames.field = "chr",
  start.field    = "start",
  end.field      = "end",
  keep.extra.columns = TRUE
)

# keep only standard chromosomes
peaks_all <- keepStandardChromosomes(peaks_all, pruning.mode = "coarse")

#  Run overlap permutation test per group
results <- lapply(unique(peaks_all$group), function(g) {
  
  peaks_grp <- peaks_all[peaks_all$group == g]
  
  pt <- overlapPermTest(
    A = peaks_grp,     # TF peaks for this group
    B = prom5kb,       # promoter ±5kb regions
    ntimes = 1000,     # number of randomizations (increase for more precision)
    genome = "hg38",   # genome used for randomization
    alternative = "greater"  # test for enrichment
  )
  
  data.frame(
    group    = g,
    observed = pt$numOverlaps$observed,
    expected = mean(pt$numOverlaps$permuted),
    zscore   = pt$numOverlaps$zscore,
    pval     = pt$numOverlaps$pval
  )
})

# Combine results into one dataframe
results_df <- do.call(rbind, results)

# 4. Inspect results
print(results_df)

# Save results
#write.csv(results_df, "/Users/rileymullins/Documents/CC_Figs_08092025/figs/TF_promoter5kb_enrichment_results.csv", row.names = FALSE)
results_df<-read.csv("/Users/rileymullins/Documents/CC_Figs_08092025/figs/TF_promoter5kb_enrichment_results.csv")






#### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### ####
#### Figure 3 ####
#### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### ####
# Load packages
suppressPackageStartupMessages({
  library(scales)
  library(future)
    library(progress)
    library(progressr)
  library(ChIPseeker)
  library(readr)
  library(data.table)
  library(purrr)
  library(stringr)
  library(tibble)
  library(ArchR)
library(dplyr)
library(future)
library(future.apply)
library(progressr)
library(broom)
library(Matrix)
library(tidyverse)
library(data.table)
library(GenomicRanges)
library(TxDb.Hsapiens.UCSC.hg38.knownGene)
library(org.Hs.eg.db)
library(patchwork)  
  library(DESeq2)
  library(tidyverse)
  library(parallel)
  library(ComplexHeatmap)
  library(tidytext)
  library(RColorBrewer)
  library(circlize)
  library(GenomicRanges)
  library(viridis)
  library(janitor)
  library(data.table)
  library(R.utils)
  library(ComplexHeatmap)
  library(circlize)  
  library(viridis)
  library(dplyr)
  library(annotatr)
  library(TxDb.Hsapiens.UCSC.hg38.knownGene)
  library(tidyr)
  library(AnnotationHub)
  library(GenomicRanges)
  library(GenomicFeatures)
  library(EnhancedVolcano)
  library(biomaRt)
  library(pathview)
  library(ggplot2)
  library(stringr)
  library(GSVA)
  library(forcats)
  library(enrichplot)
  library(clusterProfiler)
  library(org.Hs.eg.db)
  library(ReactomePA)      
  library(DOSE) 
  library(AUCell)
  library(scCustomize)
  library(gridExtra)
  library(GENIE3)
  library(ggpubr)
  library(fgsea)
  library(msigdbr)
  library(patchwork)
  library(qs)
  library(RColorBrewer)
  library(UpSetR)
  library(doRNG)
  library(sctransform)
  library(rlang)
  library(cli)
  library(ggraph)
  library(ggthemes)
  library(tidyverse)
  library(magrittr)
  library(tictoc)
  library(rstatix)
  library(cowplot)
  library(harmony)
  library(DESeq2)
  library(rhdf5)
  library(Seurat)
  library(SeuratObject)
  options(Seurat.object.assay.version = "v5")
  options(future.globals.maxSize = 1e9)
})


figdir <- "/Users/rileymullins/Documents/CC_Figs_08092025/figs/"


#------------------------------------------------------------------------------------------------------------------
#### Make list of TF targets for each group (acute and chronic) ####
#------------------------------------------------------------------------------------------------------------------

# Run the peak-gene links for ALL data
# Define dirs
python_output_dir <- "/Users/rileymullins/Documents/Acute_v_Chronic_Data"
output_dir <- file.path(python_output_dir, "STEP_4_output_deseq2_peak_analysis_ACUTE_ONLY")
bulk_rna_dir <- file.path(output_dir, "wherry_bulk_rna_seq_analysis")
bulk_atac_dir <- file.path(output_dir, "wherry_bulk_atac_analysis")
bzip_results_outdir <- file.path(bulk_atac_dir, "bZIP_combined_linear_regression")
dir.create(bzip_results_outdir, recursive = TRUE, showWarnings = FALSE)

# Define parameters for peaks near TSS search
promoter_upstream <- 5000 # Used 10000 previously
promoter_downstream <- 5000 # Used 10000 previously

# Load enhancer-gene database
dt <- fread(file="/Users/rileymullins/Documents/engreitz_cd8_t_cell_encode_re2g_links/distinct_gene_pairs_unmerged_final.csv", nThread = 12) %>%
  distinct(enh_coord, chr, start, end, gene_name)

# Load TF binding annotations from HOMER
annot_ac <- read.csv("/Users/rileymullins/Documents/Acute_v_Chronic_Data/STEP_4_output_deseq2_peak_analysis_ACUTE_ONLY/HOMER_annotations_COMBINED_all_Group_vs_Control_results.csv")
annot_ch <- read.csv("/Users/rileymullins/Documents/Acute_v_Chronic_Data/STEP_4_output_deseq2_peak_analysis_CHRONIC_ONLY/HOMER_annotations_COMBINED_all_Group_vs_Control_results.csv")
annot <- rbind(annot_ac,annot_ch)

# Load MultiAssayExperiment
mae_paired <- readRDS(file = file.path(bulk_atac_dir, "wherry_data_paired_rna_atac_multi_assay_experiment.rds"))

# Load all ACRs
group_annotation_file <- file.path(bulk_atac_dir, "all_acrs_HOMER_annotated.txt")


# Prep seq data
se_rna <- mae_paired[["rna"]]
se_atac <- mae_paired[["atac"]]
colnames(se_atac) <- mae_paired[["atac"]]$RNA_ID
atac_mat <- assay(se_atac)

# Prepare RNA matrix
rna_mat <- assay(se_rna)
rownames(rna_mat) <- rowData(se_rna)$geneSymbol
rna_mat <- rna_mat[!duplicated(rownames(rna_mat)), ]

# Process all ACR (Accessible Chromatin Region) annotations
acr_annot <- fread(group_annotation_file) %>%
  rename_with(~ gsub(" ", "_", .)) %>%
  dplyr::mutate(acr_id = paste0(Chr, "_", Start, "_", End)) %>%
  dplyr::select(acr_id, Chr, Start, End) %>%
  distinct()


# Helper function to find overlaps between TF peaks and the ACR universe
get_universe_overlaps <- function(tf_peak_df, universe_gr, maxgap = 0) {
    if (nrow(tf_peak_df) == 0) return(character(0))
    tf_gr <- tf_peak_df %>%
        separate(peak_id, into = c("chr", "start", "end"), sep = "[_:-]", convert = TRUE, fill = "right") %>%
        filter(!is.na(chr) & !is.na(start) & !is.na(end)) %>%
        makeGRangesFromDataFrame()
    hits <- findOverlaps(tf_gr, universe_gr, maxgap = maxgap)
    unique(mcols(universe_gr)$peak_id[subjectHits(hits)])
}

# Create a GRanges object of all ACRs
all_acrs_gr <- acr_annot %>%
  mutate(peak_id = acr_id) %>%
  dplyr::rename(chr = Chr, start = Start, end = End) %>%
  makeGRangesFromDataFrame(keep.extra.columns = TRUE)

## USER INPUT: Specify TF groups ##
tf_groups <- c("TOX_Acute", "TCF7_Acute","TOX2_Acute","SOX4_Acute","RBPJ_Acute",
               "TOX_Chronic","TCF7_Chronic","TOX2_Chronic","SOX4_Chronic"
)
## USER INPUT: Specify TF groups ##

# Get all unique ACRs bound by any TF in the specified groups
tf_bound_acrs_list <- lapply(tf_groups, function(tf) {
  peaks_df <- annot %>% filter(group == tf)
  get_universe_overlaps(peaks_df, all_acrs_gr)
})
tf_bound_acrs <- unique(unlist(tf_bound_acrs_list))

# Filter to ONLY TF-bound ACRs
all_acrs_gr <- all_acrs_gr[mcols(all_acrs_gr)$peak_id %in% tf_bound_acrs]

cat("Using", length(tf_groups), "TFs:", paste(tf_groups, collapse=", "), "\n")
cat("Found", length(tf_bound_acrs), "unique TF-bound ACRs to use for pairing\n")


# --- 4. FIND AND ANNOTATE PAIRS FROM PROMOTERS OR ENHANCERS ---

# Gene and TxDb setup
txdb <- TxDb.Hsapiens.UCSC.hg38.knownGene
genes_gr <- genes(txdb)
gene_map <- AnnotationDbi::select(org.Hs.eg.db, keys = genes_gr$gene_id, columns = "SYMBOL", keytype = "ENTREZID")
mcols(genes_gr)$gene_symbol <- gene_map$SYMBOL[match(genes_gr$gene_id, gene_map$ENTREZID)]
genes_gr <- genes_gr[!is.na(mcols(genes_gr)$gene_symbol) & mcols(genes_gr)$gene_symbol %in% rownames(rna_mat)]

# 1. Find all pairs linked by PROMOTER window overlap
promoter_windows <- promoters(genes_gr, upstream = promoter_upstream, downstream = promoter_downstream)
promoter_hits <- findOverlaps(all_acrs_gr, promoter_windows)
promoter_pairs <- data.frame(
  acr_id = mcols(all_acrs_gr)$peak_id[queryHits(promoter_hits)],
  gene_name = mcols(promoter_windows)$gene_symbol[subjectHits(promoter_hits)]
) %>% distinct()

# 2. Find all pairs linked by an overlapping ENHANCER from the database
enhancer_db_gr <- makeGRangesFromDataFrame(dt,
  seqnames.field = "chr",
  start.field = "start",
  end.field = "end",
  keep.extra.columns = TRUE
)
enhancer_hits <- findOverlaps(all_acrs_gr, enhancer_db_gr)
enhancer_pairs <- data.frame(
  acr_id = mcols(all_acrs_gr)$peak_id[queryHits(enhancer_hits)],
  gene_name = mcols(enhancer_db_gr)$gene_name[subjectHits(enhancer_hits)]
) %>% distinct()

# 3. Combine both lists to create the master list of all pairs ("OR" logic)
all_candidate_pairs <- bind_rows(promoter_pairs, enhancer_pairs) %>%
  distinct(acr_id, gene_name)

# 4. Annotate the master list with promoter and enhancer status
acr_gene_pairs_for_modeling <- all_candidate_pairs %>%
  # Use an inner_join with a TRUE flag to check for promoter status
  mutate(is_promoter = (paste(acr_id, gene_name) %in% paste(promoter_pairs$acr_id, promoter_pairs$gene_name))) %>%
  # Do the same for enhancer status
  mutate(is_enhancer = (paste(acr_id, gene_name) %in% paste(enhancer_pairs$acr_id, enhancer_pairs$gene_name)))

# 5. Add TF binding information back
tf_binding_info <- tibble(acr_id = tf_bound_acrs)
for (tf in tf_groups) {
  this_list <- tf_bound_acrs_list[[which(tf_groups == tf)]]
  tf_binding_info[[tf]] <- as.integer(tf_bound_acrs %in% this_list)
}

acr_gene_pairs_for_modeling <- acr_gene_pairs_for_modeling %>%
  left_join(tf_binding_info, by = "acr_id") %>%
  filter(gene_name %in% rownames(rna_mat)) # Filter to keep only pairs with the gene in the RNA matrix  


# --- 5. FINAL CHECKS AND SAVE ---

cat("\nFinal number of unique ACR-gene pairs for modeling:", nrow(acr_gene_pairs_for_modeling), "\n")
cat("Number of unique ACRs in the final set:", length(unique(acr_gene_pairs_for_modeling$acr_id)), "\n")
cat("Number of unique genes in the final set:", length(unique(acr_gene_pairs_for_modeling$gene_name)), "\n\n")

# Display a summary of the annotations
print(table(Promoter = acr_gene_pairs_for_modeling$is_promoter, Enhancer = acr_gene_pairs_for_modeling$is_enhancer))

# Save the final data frame
#write.csv(acr_gene_pairs_for_modeling, file = file.path(figdir, "ALL_ACUTE_AND_CHRONIC_TFs_acr_gene_pairs_for_modeling.csv"), row.names = FALSE)
acr_gene_pairs_for_modeling<-read.csv(file = file.path(figdir, "ALL_ACUTE_AND_CHRONIC_TFs_acr_gene_pairs_for_modeling.csv"))

# Run regression and correlation. Regression is simple peak ~ gene and unadjusted for all peaks on the gene
paired_acrs <- unique(acr_gene_pairs_for_modeling$acr_id)
paired_genes <- unique(acr_gene_pairs_for_modeling$gene_name)
rna_mat_filter <- rna_mat[paired_genes, , drop = FALSE]
atac_mat_filter <- atac_mat[paired_acrs, , drop = FALSE]
common_samps <- intersect(colnames(rna_mat_filter), colnames(atac_mat_filter))
if (length(common_samps) == 0) stop("No common samples between RNA and ATAC matrices.")
rna_mat_filter <- rna_mat_filter[, common_samps, drop = FALSE]
atac_mat_filter <- atac_mat_filter[, common_samps, drop = FALSE]

plan(multisession, workers = 10)
handlers(global = TRUE)
handlers("progress")

batch_size <- 10000
n_pairs <- nrow(acr_gene_pairs_for_modeling)
n_batches <- ceiling(n_pairs / batch_size)
n_pairs
n_batches
all_model_results <- list()

with_progress({
  p_overall <- progressor(along = 1:n_batches)
  
  for (batch_i in 1:n_batches) {
    message(sprintf("Processing batch %d of %d", batch_i, n_batches))
    
    start_idx <- (batch_i - 1) * batch_size + 1
    end_idx <- min(batch_i * batch_size, n_pairs)
    
    batch_pairs <- acr_gene_pairs_for_modeling[start_idx:end_idx, ]
    
    batch_results <- future_lapply(1:nrow(batch_pairs), function(i) {
      pair <- batch_pairs[i, ]
      gene <- pair$gene_name
      acr <- pair$acr_id
      
      # Check if gene and peak exist in filtered matrices
      if (!(gene %in% rownames(rna_mat_filter)) || !(acr %in% rownames(atac_mat_filter))) {
        return(NULL)
      }
      
      expr_vec <- as.numeric(rna_mat_filter[gene, ])
      peak_vec <- as.numeric(atac_mat_filter[acr, ])
      
      # Prepare data frame for regression (raw values, not z-scored)
      df <- data.frame(gene_expression = expr_vec, peak_accessibility = peak_vec)
      
      # Fit simple linear regression: gene_expression ~ peak_accessibility
      fit <- tryCatch(lm(gene_expression ~ peak_accessibility, data = df), error = function(e) NULL)
      if (is.null(fit)) return(NULL)
      
      model_info <- broom::glance(fit)
      tidy_coef <- broom::tidy(fit) %>%
        filter(term == "peak_accessibility") %>%
        transmute(
          gene = gene,
          acr_id = acr,
          beta = estimate,             # raw slope
          p_value = p.value,
          r_squared = model_info$r.squared,
          adj_r_squared = model_info$adj.r.squared
        )
      
      # Spearman correlation on raw values
      cor_test <- suppressWarnings(cor.test(expr_vec, peak_vec, method = "spearman"))
      
      tidy_coef$spearman_rho <- cor_test$estimate
      tidy_coef$spearman_p <- cor_test$p.value
      
      tidy_coef
    }, future.seed = TRUE)
    
    all_model_results[[batch_i]] <- do.call(rbind, Filter(Negate(is.null), batch_results))
    
    p_overall(sprintf("Completed batch %d/%d", batch_i, n_batches))
    gc()
  }
})
plan(sequential)


# Collect results
all_model_results_merged <- dplyr::bind_rows(all_model_results) %>%
  group_by(gene) %>%
  dplyr::mutate(fdr_lm = p.adjust(p_value, method = "BH"),
         fdr_spearman = p.adjust(spearman_p, method = "BH")
         ) %>%
  ungroup() %>%
  dplyr::select(gene, acr_id, r_squared, beta, fdr_lm, spearman_rho, fdr_spearman) %>%
  arrange(desc(abs(beta)), fdr_lm)

# Join the modeling results with the promoter/enhancer annotations
final_annotated_results <- all_model_results_merged %>%
  left_join(acr_gene_pairs_for_modeling, by = c("gene" = "gene_name", "acr_id" = "acr_id")) %>%
  # Create a final annotation column
  dplyr::mutate(
    annotation = case_when(
      is_promoter == TRUE & is_enhancer == TRUE  ~ "Promoter_Enhancer",
      is_promoter == TRUE & is_enhancer == FALSE ~ "Promoter",
      is_promoter == FALSE & is_enhancer == TRUE ~ "Enhancer",
      TRUE                                      ~ "Other" # Should not happen with this logic
    )
  )

# This counts how many times each TF is associated with an ACR in the results
tf_summary <- final_annotated_results %>%
  # Select only the TF columns
  dplyr::select(all_of(tf_groups)) %>%
  # Calculate the sum for each column (na.rm = TRUE ignores any missing values)
  dplyr::summarise_all(~sum(., na.rm = TRUE)) %>%
  # Reshape the data from wide to long format for easy reading and plotting
  pivot_longer(cols = everything(), names_to = "Transcription_Factor", values_to = "Count") %>%
  # Arrange the TFs by count in descending order
  arrange(desc(Count))

# Print the summary table 
print(tf_summary)

# Save
#write.csv(final_annotated_results,file = file.path(figdir,"ALL_ACUTE_AND_CHRONIC_final_annotated_results_from_acr_gene_pairs_for_modeling.csv"))
final_annotated_results <- read.csv( file = file.path(figdir,"ALL_ACUTE_AND_CHRONIC_final_annotated_results_from_acr_gene_pairs_for_modeling.csv"))

# Filter
all_model_results_final <- final_annotated_results %>% filter(  fdr_lm < 0.05 &        # Significant lin regression
                                                                fdr_spearman < 0.05 &  # Significant rho
                                                                beta > 0.15 &     # Effect size cutoff (1 count in atac peak ~ 0.25 counts in gene)
                                                                r_squared > 0.15) %>%   # Fit cutoff
  dplyr::mutate(abs_rho = abs(spearman_rho),
         abs_beta = abs(beta),
         acr_gene = paste0(acr_id,"_x_",gene)
) 

nrow(all_model_results_final)
summary(all_model_results_final)

# Count how many times each TF is associated with an ACR in the results
tf_summary <- all_model_results_final %>%
  # Select only the TF columns
  dplyr::select(all_of(tf_groups)) %>%
  # Calculate the sum for each column (na.rm = TRUE ignores any missing values)
  dplyr::summarise_all(~sum(., na.rm = TRUE)) %>%
  # Reshape the data from wide to long format for easy reading and plotting
  pivot_longer(cols = everything(), names_to = "Transcription_Factor", values_to = "Count") %>%
  # Arrange the TFs by count in descending order
  arrange(desc(Count))

# Print the summary table 
print(tf_summary)

# Save filtered
#write.csv(all_model_results_final,file = file.path(figdir,"ALL_ACUTE_AND_CHRONIC_FILTERED_final_annotated_results_from_acr_gene_pairs_for_modeling.csv"))
all_model_results_final<-read.csv(file = file.path(figdir,"ALL_ACUTE_AND_CHRONIC_FILTERED_final_annotated_results_from_acr_gene_pairs_for_modeling.csv"))


# Add in promoter-bound genes (within 1kb of TSS) to all_model_results_final
new_rows_list <- list()

# 1. Define 1kb promoter regions once for efficiency.
promoter_1kb_gr <- promoters(genes_gr, upstream = 1000, downstream = 1000)

# 2. Loop through each TF to find specific new gene links.
for (tf in tf_groups) {
  
  # a. Find all genes whose promoters are bound by this specific TF.
  tf_peak_df <- annot %>% filter(group == tf)
  if (nrow(tf_peak_df) == 0) next # Skip if this TF has no peaks.

  tf_gr <- tf_peak_df %>%
    separate(peak_id, into = c("chr", "start", "end"), sep = "[_:-]", convert = TRUE, fill = "right") %>%
    filter(!is.na(chr) & !is.na(start) & !is.na(end)) %>%
    makeGRangesFromDataFrame()
    
  hits <- findOverlaps(tf_gr, promoter_1kb_gr)
  if (length(hits) == 0) next # Skip if this TF's peaks don't overlap any promoters.

  promoter_bound_genes_for_this_tf <- unique(mcols(promoter_1kb_gr)$gene_symbol[subjectHits(hits)])


  # c. Identify the new genes to add for this specific TF.
  new_genes_to_add <- promoter_bound_genes_for_this_tf

  # d. Create a data frame with the new rows if any exist.
  if (length(new_genes_to_add) > 0) {
    message(sprintf("For TF '%s', found %d new gene(s) with promoter binding not already annotated as a Promoter.", tf, length(new_genes_to_add)))
    
    new_df <- tibble(
      gene = new_genes_to_add,
      acr_id = NA_character_,
      annotation = "non_acr_promoter"
    )
    
    # Add a column for the current TF and set its value to 1.
    new_df[[tf]] <- 1
    
    new_rows_list[[tf]] <- new_df
  }
}


# Combine all the new data frames from the list.
all_new_rows <- bind_rows(new_rows_list)

# A single gene might be added by multiple TFs. We group by gene to create a single
# row for it, summing the TF flags to capture all associations.
final_new_rows <- all_new_rows %>%
    group_by(gene, acr_id, annotation) %>%
    dplyr::summarise(across(all_of(tf_groups), ~sum(., na.rm = TRUE)), .groups = "drop")

# Add the fully processed new rows to the original results.
all_model_results_final <- bind_rows(all_model_results_final, final_new_rows)

# Save filtered
#write.csv(all_model_results_final,file = file.path(figdir,"with_promoter_genes_added_back_ALL_ACUTE_AND_CHRONIC_FILTERED_final_annotated_results_from_acr_gene_pairs_for_modeling.csv"))
all_model_results_final<-read.csv(file = file.path(figdir,"with_promoter_genes_added_back_ALL_ACUTE_AND_CHRONIC_FILTERED_final_annotated_results_from_acr_gene_pairs_for_modeling.csv"))
all_model_results_final






# Plot TOX and TCF7 expression
genes_of_interest <- c("TCF7", "TOX") # TOX and TCF7 only


cluster_order <- c("Naive", "SCM-R3-", "SCM-R3+", "CM", "EM1", "EM2", "EMRA","PD1+CD39+")

# 1b. Prepare the data frame for ggplot
plot_data_bulk <- rna_mat[genes_of_interest, , drop = FALSE] %>%
  t() %>%
  as.data.frame() %>%
  rownames_to_column(var = "SampleID") %>%
  # Convert rownames of metadata to a column before joining
  left_join(
    as.data.frame(colData(se_rna)) %>% rownames_to_column(var = "SampleID"),
    by = "SampleID"
  ) %>%
  # Reshape data into a "long" format for ggplot
  pivot_longer(
    cols = all_of(genes_of_interest),
    names_to = "Gene",
    values_to = "Expression"
  ) %>%
  # Set the order for the x-axis
  dplyr::mutate(Cluster = factor(Cell_Subset, levels = cluster_order))


# Reorder
# Reorder genes so TCF7 is first, then TOX
plot_data_bulk$Gene <- factor(plot_data_bulk$Gene, levels = c("TCF7", "TOX"))

# Get distinct cluster names and assign turbo colors
clusters <- levels(factor(plot_data_bulk$Cluster))
turbo_colors <- viridis::turbo(length(clusters))

# Create named vector for scale_fill_manual
turbo_palette <- setNames(turbo_colors, clusters)

# Plot
expression_plot <- ggplot(plot_data_bulk, aes(x = Cluster, y = Expression, fill = Cluster)) +
  geom_boxplot(outlier.shape = NA, width = 0.75, alpha = 0.8) +
  geom_jitter(size = 0.25, width = 0.2, alpha = 0.5) +
  facet_wrap(~Gene, scales = "free", ncol = 2) +
 # scale_y_continuous(limits = c(0, NA), expand = expansion(mult = c(0.05, 0.05))) +
  theme_minimal() +
  labs(y = "Normalized Expression", x = NULL) +
  theme(
    plot.title = element_blank(),
    axis.title = element_text(color = "black", size = 10, face = "bold"),
    axis.text.y = element_text(color = "black", size = 10),
    axis.text.x = element_text(color = "black", size = 10, angle = 45, hjust = 1),
    strip.text = element_text(color = "black", size = 10, face = "bold"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(color = "black"),
    legend.position = "none"
  ) +
  scale_fill_manual(values = turbo_palette)

expression_plot

# 1e. Save plot
ggsave(
  file.path(figdir, "TOX_TCF7_Bulk_Expr.png"),
  expression_plot, width =5, height = 2.5, dpi = 300, bg = "white"
)
ggsave(
  file.path(figdir, "TOX_TCF7_Bulk_Expr.pdf"),
  expression_plot, width = 5, height = 2.5, bg = "white"
)







# Heatmap of enhancer-gene pairs
# Loop wrapper that reuses original heatmap code but enforces identical width/height
library(dplyr)
library(ComplexHeatmap)
library(circlize)
library(ArchR)
library(grid)
library(data.table)



# Define dirs
python_output_dir <- "/Users/rileymullins/Documents/Acute_v_Chronic_Data"
output_dir <- file.path(python_output_dir, "STEP_4_output_deseq2_peak_analysis_ACUTE_ONLY")
bulk_rna_dir <- file.path(output_dir, "wherry_bulk_rna_seq_analysis")
bulk_atac_dir <- file.path(output_dir, "wherry_bulk_atac_analysis")
bzip_results_outdir <- file.path(bulk_atac_dir, "bZIP_combined_linear_regression")
dir.create(bzip_results_outdir, recursive = TRUE, showWarnings = FALSE)

# --- 2. PREPARE DATA ---

# Load MultiAssayExperiment
mae_paired <- readRDS(file = file.path(bulk_atac_dir, "wherry_data_paired_rna_atac_multi_assay_experiment.rds"))
se_rna <- mae_paired[["rna"]]
se_atac <- mae_paired[["atac"]]
colnames(se_atac) <- mae_paired[["atac"]]$RNA_ID
atac_mat <- assay(se_atac)

# Prepare RNA matrix
rna_mat <- assay(se_rna)
rownames(rna_mat) <- rowData(se_rna)$geneSymbol
rna_mat <- rna_mat[!duplicated(rownames(rna_mat)), ]

# Extract sets
tox_targets  <- all_model_results_final %>% filter(TOX_Acute == 1) %>% filter(!acr_id %in% NA) %>% pull(acr_gene) %>% unique()
tcf7_targets <- all_model_results_final %>% filter(TCF7_Acute == 1) %>% filter(!acr_id %in% NA) %>% pull(acr_gene) %>% unique()

# Create named list of sets
acr_gene_sets <- list(TCF7 = tcf7_targets, TOX = tox_targets)


# ---------- Build the three sets  ----------
tcf7_sp <- all_model_results_final %>% filter(acr_gene %in% setdiff(acr_gene_sets$TCF7, acr_gene_sets$TOX))
tox_sp  <- all_model_results_final %>% filter(acr_gene %in% setdiff(acr_gene_sets$TOX,  acr_gene_sets$TCF7))
common  <- all_model_results_final %>% filter(acr_gene %in% intersect(acr_gene_sets$TCF7, acr_gene_sets$TOX))
head(common)

sets_list <- list(
  TCF7_specific = tcf7_sp,
  TOX_specific  = tox_sp,
  Common        = common
)

# ---------- Determine maximum rows across sets so heatmaps have the same height ----------
n_rows_per_set <- sapply(sets_list, function(df) nrow(df %>% distinct(acr_id, gene)))
n_rows_max <- max(n_rows_per_set, 1)

# ---------- Determine number of columns (samples) from existing ordering if available ----------
if (exists("final_col_order_atac")) {
  n_cols <- length(final_col_order_atac)
} else {
  coldata_df <- as.data.frame(colData(mae_paired))
  if ("ATAC_ID" %in% colnames(coldata_df)) {
    final_col_order_atac <- coldata_df$ATAC_ID
  } else {
    final_col_order_atac <- coldata_df$RNA_ID
  }
  n_cols <- length(final_col_order_atac)
}

# ---------- Keep original cell sizes ----------
cell_width <- unit(0.2, "mm")
cell_height <- unit(0.14, "mm")

total_heatmap_width  <- n_cols * cell_width
total_heatmap_height <- n_rows_max * cell_height

# Convert to numeric mm for device sizing (png/pdf)
total_width_mm  <- as.numeric(convertUnit(total_heatmap_width, "mm"))
total_height_mm <- as.numeric(convertUnit(total_heatmap_height, "mm"))

# ---------- Loop through sets and run original heatmap code for each set ----------
outdir <- file.path(figdir, "heatmaps_by_set")
dir.create(outdir, recursive = TRUE, showWarnings = FALSE)

for (set_name in names(sets_list)) {
  message("Processing set: ", set_name)
  filtered_data_tox <- sets_list[[set_name]]
  
  # If the set is empty skip to next
  if (nrow(filtered_data_tox) == 0) {
    message("  Skipping empty set: ", set_name)
    next
  }
  
  # ------------------ BEGIN: ORIGINAL heatmap code  ------------------
  # Prepare Assay Matrices and Metadata 
  atac_mat <- assay(mae_paired[["atac"]])
  rna_mat  <- assay(mae_paired[["rna"]])
  
  # Set rownames to gene symbol
  rownames(rna_mat) <- rowData(mae_paired[["rna"]])$geneSymbol
  # Remove dup rows
  rna_mat <- rna_mat[!duplicated(rownames(rna_mat)), ]
  
  # Subset matrices
  atac_mat_sub <- atac_mat[filtered_data_tox$acr_id, , drop = FALSE]
  rna_mat_sub  <- rna_mat[filtered_data_tox$gene, , drop = FALSE]
  
  # Transform Data (Z-scores) 
  row_zscores <- function(mat, limits = c(-2, 2)) {
    z <- t(scale(t(mat)))
    z[z > limits[2]] <- limits[2]
    z[z < limits[1]] <- limits[1]
    return(z)
  }
  atac_z <- row_zscores(atac_mat_sub)
  rna_z  <- row_zscores(rna_mat_sub)
  
  # Prepare Metadata and Order Columns 
  if (!exists("cell_subset_order")) {
    cell_subset_order <- c("Naive", "SCM-R3-", "SCM-R3+", "CM", "EM1", "EM2", "EMRA", "PD1+CD39+")
  }
  coldata_df <- as.data.frame(colData(mae_paired)) %>%
    dplyr::mutate(Cell_Subset = factor(Cell_Subset, levels = cell_subset_order)) %>%
    filter(!is.na(Cell_Subset))
  
  cluster_colors <- viridis::turbo(length(cell_subset_order))
  cluster_color_mapping <- setNames(cluster_colors, cell_subset_order)
  
  ordered_cols_df <- coldata_df %>%
    arrange(factor(Cell_Subset, levels = cell_subset_order))
  
  # Create initial biologically-ordered matrices
  atac_z_ordered <- atac_z[, ordered_cols_df$ATAC_ID, drop = FALSE]
  rna_z_ordered  <- rna_z[, ordered_cols_df$RNA_ID,  drop = FALSE]
  
  # ---------- INSERTED: Determine Final Column Order via K-Means 
  set.seed(1)
  k <- 3
  km_result_cols <- kmeans(t(rna_z_ordered), centers = k, nstart = 50)
  
  # reorder levels but guard against missing names
  try({
    # if those named entries exist in km_result_cols$cluster, use them as ordering
    named_idxs <- c("R_S7007", "R_S7006", "R_S8023")
    if (all(named_idxs %in% names(km_result_cols$cluster))) {
      km_result_cols$cluster <- factor(km_result_cols$cluster, levels = c(
        km_result_cols$cluster["R_S7007"],
        km_result_cols$cluster["R_S7006"],
        km_result_cols$cluster["R_S8023"]
      ))
    } else {
      # fallback to simple factor of clusters
      km_result_cols$cluster <- factor(km_result_cols$cluster)
    }
  }, silent = TRUE)
  
  # Create a data frame with column info and cluster assignments
  col_cluster_df <- data.frame(
    ATAC_ID = colnames(atac_z_ordered),
    cluster = km_result_cols$cluster
  ) %>%
    left_join(ordered_cols_df, by = "ATAC_ID") %>%
    arrange(cluster, Cell_Subset)
  
  # Get the final column order and splits for the heatmap
  final_col_order_atac <- col_cluster_df$ATAC_ID
  final_col_order_rna  <- col_cluster_df$RNA_ID
  column_splits <- col_cluster_df$cluster
  
  # Determine Final Row Order 
  atac_z_col_ordered <- atac_z_ordered[, final_col_order_atac, drop = FALSE]
  rna_z_col_ordered  <- rna_z_ordered[, final_col_order_rna,  drop = FALSE]
  
  # Order genes and peaks by delta expression in naive and EM and PD1/CD39
  naive_cols <- col_cluster_df %>%
    filter(Cell_Subset == "Naive") %>%
    pull(RNA_ID)
  mean_rna_in_naive <- rowMeans(rna_z_col_ordered[, naive_cols, drop = FALSE], na.rm = TRUE)
  
  pd1_cols <- col_cluster_df %>%
    filter(Cell_Subset %in% c("EM1","EM2","EMRA", "PD1+CD39+")) %>%
    pull(RNA_ID)
  mean_rna_in_pd1 <- rowMeans(rna_z_col_ordered[, pd1_cols, drop = FALSE], na.rm = TRUE)
  
  # Perform k-means on the rows
  set.seed(1)
  km_result_rows <- kmeans(rna_z_ordered, centers = 2, nstart = 50, iter.max = 1000)
  
  # Determine which k-means cluster is "High" vs "Low" based on naive expression
  cluster_means <- tapply(mean_rna_in_naive, km_result_rows$cluster, mean)
  high_expr_cluster <- names(cluster_means)[which.max(cluster_means)]
  low_expr_cluster  <- names(cluster_means)[which.min(cluster_means)]
  
  # Add the descriptive names to the dataframe for clarity
  p2g_with_clusters <- filtered_data_tox %>%
    dplyr::rename(
      peak_id = acr_id,
      gene_symbol = gene
    ) %>%
    dplyr::mutate(
      km_cluster_id = km_result_rows$cluster
    ) %>%
    # Map numeric cluster IDs to descriptive names
    dplyr::mutate(
      km_cluster_name = factor(
        km_cluster_id,
        levels = c(high_expr_cluster, low_expr_cluster),
        labels = c("Naive", "Effector")
      )
    )
  
  # Save the annotated peak-to-gene pairs
  write.csv(
    p2g_with_clusters,
    file = file.path(outdir, paste0(set_name,"_peak_gene_pairs_bulk_rna_heatmap_genes_in_each_km_cluster.csv")),
    row.names = FALSE
  )
  
  # Determine rows per cluster
  rows_high <- which(km_result_rows$cluster == high_expr_cluster)
  rows_low  <- which(km_result_rows$cluster == low_expr_cluster)
  
  # Sort clusters by expression
  sorted_high <- rows_high[order(mean_rna_in_naive[rows_high], decreasing = TRUE)]
  sorted_low  <- rows_low[order(mean_rna_in_pd1[rows_low], decreasing = FALSE)]
  
  # Combine for final row order
  final_row_order <- c(sorted_high, sorted_low)
  
  # Apply final ordering to create final matrices and gene list
  atac_final_reordered <- atac_z_col_ordered[final_row_order, , drop = FALSE]
  rna_final_reordered  <- rna_z_col_ordered[final_row_order, , drop = FALSE]
  final_genes_ordered  <- p2g_with_clusters$gene_symbol[final_row_order]
  
  # Create descriptive row splits
  row_split_factor <- factor(
    c(rep("Naive", length(sorted_high)),
      rep("Effector", length(sorted_low))),
    levels = c("Naive", "Effector")
  )
  
  # Create Final Annotations (Now Aligned with Final Data) 
  interesting_genes_list <- c(
    "PDCD1", "TNFRSF9", "TNF", "FASLG", "BHLHE40", "ARID5B", "FYN", "GZMB","KLF7","FOSL2",
    "IL2RA", "IL2RB", "IRF4", "TCF7", "FOSL1", "JUN", "BATF", "DKK3",
    "LAG3",  "KLRG1", "RUNX1", "RUNX2", "RUNX3",
      "RBPJ", "NFATC3", "NFAT5", "FAS", "PRDM1", "BACH2", "ID2",
    "ID3", "NFKB1", "FOXP1", "IL7R", "SOX4", "RELA", "FOS", "IFNG", "IKZF2", "IRF2",
    "CD28", "CTLA4", "TOX", "TOX2", "ICOS", "TIGIT", "CD69",
    "LEF1", "CCR7", "FOXO1", "STAT5A", "STAT5B", "IKZF3",
    "AHR","LAYN","KAT6A","BACH2","KAT2B","CD27",
    "KLF2","MAF","MAL","SELL","TNFRSF1B","CCR5","NFKBIZ","IL15RA"
  )
  
  idx_to_label <- sapply(interesting_genes_list, function(gene) {
    which_gene <- which(final_genes_ordered == gene)
    if (length(which_gene) == 0) return(NA)
    gene_means <- rowMeans(rna_final_reordered[which_gene, , drop = FALSE])
    which_gene[which.max(gene_means)]
  })
  idx_to_label <- unique(na.omit(idx_to_label))
  
  gene_label_annotation <- rowAnnotation(
    Labels = anno_mark(at = idx_to_label, labels = final_genes_ordered[idx_to_label], labels_gp = gpar(fontsize = 7)),
    width = unit(2, "cm")
  )
  
  # The final column annotation must use the re-ordered metadata
  final_col_annotation <- HeatmapAnnotation(
    `Cell Subset` = factor(col_cluster_df$Cell_Subset, levels = cell_subset_order),
    col = list(`Cell Subset` = cluster_color_mapping),
    show_annotation_name = FALSE,
    simple_anno_size = unit(0.25, "cm"),
    annotation_legend_param = list(
      title_gp  = gpar(fontsize = 7, fontface = "bold"),
      labels_gp = gpar(fontsize = 7, fontface = "plain")
    )
  )
 
  
   
#### MAKE LEFT ANNOTATION ####

# Get the ordered pairs that correspond to the heatmap rows
final_heatmap_pairs <- filtered_data_tox[final_row_order, ]

# Create regulation vector per pair (This part is unchanged)
regulation_vec <- case_when(
    final_heatmap_pairs$annotation == "Promoter" ~ "TSS-Proximal",
    final_heatmap_pairs$annotation == "Promoter_Enhancer" ~ "TSS-Proximal Enhancer",
    final_heatmap_pairs$annotation == "Enhancer" ~ "Enhancer",
    TRUE ~ NA_character_
)
regulation_vec <- factor(regulation_vec, levels = c("TSS-Proximal", "TSS-Proximal Enhancer", "Enhancer"))

# Define colors for both annotations (This part is unchanged)
regulation_colors <- c(
    "TSS-Proximal" = "#FF5733",
    "TSS-Proximal Enhancer" = "#33CC33",
    "Enhancer" = "#3355FF"
)

# 1. DEFINE colors for the new k-means cluster annotation
km_cluster_row_colors <- c("Naive" = "lightblue", "Effector" = "navy")

# 2. BUILD the left row annotation, combining the new cluster annotation with the existing site annotation
left_ha <- rowAnnotation(
    # New annotation for the k-means cluster
    `KM Cluster` = row_split_factor,

    # Existing annotation for the site type
    Site = regulation_vec,

    # Provide a list of colors for BOTH annotations
    col = list(
        `KM Cluster` = km_cluster_row_colors,
        Site = regulation_colors
    ),

    # General styling for annotation names
    annotation_name_side = "top",
    annotation_name_gp = gpar(fontsize = 7),

    # This sets the width for BOTH annotation bars, ensuring they are identical
    simple_anno_size = unit(2, "mm"),

    # Set legend parameters for EACH annotation individually
    annotation_legend_param = list(
        `KM Cluster` = list(
            title_gp = gpar(fontsize = 7, fontface = "bold"),
            labels_gp = gpar(fontsize = 7)
        ),
        Site = list(
            title_gp = gpar(fontsize = 7, fontface = "bold"),
            labels_gp = gpar(fontsize = 7)
        )
    )
)

#####

# Set colors and widht/height
  pal_atac <- paletteContinuous("blueYellow")
  pal_rna  <- paletteContinuous("horizonExtra")
  color_fun_atac <- colorRamp2(seq(-2, 2, length.out = length(pal_atac)), pal_atac)
  color_fun_rna <- colorRamp2(seq(-2, 2, length.out = length(pal_rna)), pal_rna)
  
  # Use the total_heatmap_width/height computed outside (based on max rows across sets)
  total_heatmap_width  <- total_heatmap_width
  total_heatmap_height <- total_heatmap_height
  
  # Check against the annotation table to be sure peak-gene links are in same order
  expected_pairs <- filtered_data_tox[final_row_order, ]
  stopifnot(rownames(atac_final_reordered) == expected_pairs$acr_id)
  stopifnot(rownames(rna_final_reordered) == expected_pairs$gene)
  
# Make heatmaps
  ht_atac <- Heatmap(
    atac_final_reordered,
    name = "ATAC Z-Score",
    col = color_fun_atac,
    top_annotation = final_col_annotation,
    width = total_heatmap_width,
    height = total_heatmap_height,
   # left_annotation = left_ha,
    cluster_columns = FALSE,
    cluster_rows = TRUE,
    show_row_dend = FALSE,
    row_dend_reorder = TRUE,
    cluster_row_slices = FALSE,
    show_row_names = FALSE,
    show_column_names = FALSE,
    column_title_gp = gpar(fontsize = 8, fontface = "bold"),
    row_title_gp = gpar(fontsize = 8, fontface = "bold"),
    column_split = column_splits,
    row_split = row_split_factor,
    column_title = "ATAC Peak Signal",
    border = TRUE,
    row_dend_side = "left",
    use_raster = TRUE,
    raster_quality = 10,
    heatmap_legend_param = list(title = "ATAC Z-score", title_gp = gpar(fontsize = 7, fontface = "bold"), labels_gp = gpar(fontsize = 7))
  )
  
  ht_rna <- Heatmap(
    rna_final_reordered,
    name = "RNA Z-Score",
    col = color_fun_rna,
    right_annotation = gene_label_annotation,
    top_annotation = final_col_annotation,
    cluster_columns = FALSE,
    width = total_heatmap_width,
    height = total_heatmap_height,
    cluster_rows = FALSE,
    show_row_names = FALSE,
    show_column_names = FALSE,
    column_title_gp = gpar(fontsize = 8, fontface = "bold"),
    row_title_gp = gpar(fontsize = 8, fontface = "bold"),
    column_split = column_splits,
    row_title = NULL,
    column_title = "RNA Gene Expr",
    border = TRUE,
    use_raster = TRUE,
    raster_quality = 10,
    heatmap_legend_param = list(title = "RNA Z-score", title_gp = gpar(fontsize = 7, fontface = "bold"), labels_gp = gpar(fontsize = 7))
  )
  
  # Save with identical mm device size computed above
  png(file.path(outdir, paste0("peak_gene_links_matched_heatmap_", set_name, ".png")),
      width = 5, height = 6.5, units = "in", res = 300)
  ComplexHeatmap::draw(ht_atac + ht_rna,
       heatmap_legend_side = "right",
       annotation_legend_side = "right",
       ht_gap                 = unit(0.05, "mm"),
       legend_gap             = unit(0.5, "mm"),
       merge_legend = TRUE)
  dev.off()
  
  pdf(file.path(outdir, paste0("peak_gene_links_matched_heatmap_", set_name, ".pdf")),
      width = 10, height = 10) 
  ComplexHeatmap::draw(ht_atac + ht_rna,
       heatmap_legend_side = "right",
       annotation_legend_side = "right",
       ht_gap                 = unit(0.05, "mm"),
       legend_gap             = unit(0.5, "mm"),
       merge_legend = TRUE)
  dev.off()

  message("Saved heatmaps for set: ", set_name)
}











# Permutation and Fisher test for TOX and TCF7 binding at enhancer regions

# Load data
final_annotated_results <- read.csv( file = file.path(figdir,"ALL_ACUTE_AND_CHRONIC_final_annotated_results_from_acr_gene_pairs_for_modeling.csv"))

all_model_results_final<-read.csv(file = file.path(figdir,"ALL_ACUTE_AND_CHRONIC_FILTERED_final_annotated_results_from_acr_gene_pairs_for_modeling.csv"))



enhancer_counts_before_filtering <- final_annotated_results %>%
  distinct(acr_id, .keep_all = T)%>%
  # Filter to include only pairs where the ACR is linked via an enhancer
  filter(is_enhancer == TRUE) %>%
  # Select only the columns corresponding to the TFs
  select(all_of(tf_groups)) %>%
  # Calculate the total binding events for each TF
  summarise_all(~sum(., na.rm = TRUE)) %>%
  # Convert the data from a wide to a long format for easier viewing
  pivot_longer(cols = everything(), names_to = "Transcription_Factor", values_to = "Enhancer_Region_Count") %>%
  # Sort the results in descending order
  arrange(desc(Enhancer_Region_Count))

# Print the summary table
cat("--- TF Counts in Enhancer Regions (Before Filtering) ---\n")
print(enhancer_counts_before_filtering)


## Count Enhancer Regions Bound by Each TF (After Filtering)
# This calculation is based on the subset of enhancer-gene pairs that passed
# the significance and effect size filters (fdr < 0.05, beta > 0.15, etc.).

enhancer_counts_after_filtering <- all_model_results_final %>%
    distinct(acr_id, .keep_all = T)%>%
  # Filter to include only pairs where the ACR is linked via an enhancer
  filter(is_enhancer == TRUE) %>%
  # Select only the columns corresponding to the TFs
  select(all_of(tf_groups)) %>%
  # Calculate the total binding events for each TF
  summarise_all(~sum(., na.rm = TRUE)) %>%
  # Convert the data from a wide to a long format
  pivot_longer(cols = everything(), names_to = "Transcription_Factor", values_to = "Enhancer_Region_Count") %>%
  # Sort the results in descending order
  arrange(desc(Enhancer_Region_Count))

# Print the summary table
cat("\n--- TF Counts in Enhancer Regions (After Filtering) ---\n")
print(enhancer_counts_after_filtering)





binding_summary <- final_annotated_results %>%
  mutate(
    bound_by_TOX = (TOX_Acute == 1),
    bound_by_TCF7 = (TCF7_Acute == 1)
  )%>%  
  dplyr::mutate(
         acr_gene = paste0(acr_id,"_x_",gene)
) 

# 1. Calculate the total unique ACRs bound by BOTH TOX and TCF7
count_both_tox_tcf7 <- binding_summary %>%
  filter(bound_by_TOX & bound_by_TCF7) %>%
  summarise(unique_acr_count = n_distinct(acr_gene)) %>%
  pull(unique_acr_count)

# 2. Calculate the total unique ACRs bound ONLY by TOX (and not TCF7)
count_only_tox <- binding_summary %>%
  filter(bound_by_TOX & !bound_by_TCF7) %>%
  summarise(unique_acr_count = n_distinct(acr_gene)) %>%
  pull(unique_acr_count)

# 3. Calculate the total unique ACRs bound ONLY by TCF7 (and not TOX)
count_only_tcf7 <- binding_summary %>%
  filter(!bound_by_TOX & bound_by_TCF7) %>%
  summarise(unique_acr_count = n_distinct(acr_gene)) %>%
  pull(unique_acr_count)

# --- Print the Results ---
cat("--- Summary of Unique ACRs Bound by TOX and TCF7 ---\n")
cat("Total unique ACRs bound by BOTH TOX and TCF7:", count_both_tox_tcf7, "\n")
cat("Total unique ACRs bound ONLY by TOX:", count_only_tox, "\n")
cat("Total unique ACRs bound ONLY by TCF7:", count_only_tcf7, "\n")




binding_summary <- final_annotated_results %>%
  mutate(
    bound_by_TOX = (TOX_Acute == 1),
    bound_by_TCF7 = (TCF7_Acute == 1)
  ) %>%
  mutate(
    acr_gene = paste0(acr_id, "_x_", gene)
  )

# Calculate the total unique acr_gene pairs bound by EITHER TOX or TCF7
count_either_tox_or_tcf7 <- binding_summary %>%
  # Filter for rows where the pair is bound by TOX OR TCF7
  filter(bound_by_TOX | bound_by_TCF7) %>%
  # Get the count of distinct acr_gene pairs
  summarise(unique_count = n_distinct(acr_id)) %>%
  # Extract the final numerical value
  pull(unique_count)

# --- Print the Result ---
cat("--- Summary of Unique ACR-Gene Pairs ---\n")
cat("Total unique pairs bound by EITHER TOX or TCF7:", count_either_tox_or_tcf7, "\n")

# For verification, this number should equal the sum of the three categories
# ('only TOX', 'only TCF7', and 'both')
verification_total <- count_only_tox + count_only_tcf7 + count_both_tox_tcf7
cat("Verification by summing previous counts:", verification_total, "\n")





binding_summary <- all_model_results_final %>%
  mutate(
    bound_by_TOX = (TOX_Acute == 1),
    bound_by_TCF7 = (TCF7_Acute == 1)
  ) %>%  
  dplyr::mutate(
         acr_gene = paste0(acr_id,"_x_",gene)
) 

# 1. Calculate the total unique ACRs bound by BOTH TOX and TCF7
count_both_tox_tcf7 <- binding_summary %>%
  filter(bound_by_TOX & bound_by_TCF7) %>%
  summarise(unique_acr_count = n_distinct(paste0(acr_id))) %>%
  pull(unique_acr_count)

# 2. Calculate the total unique ACRs bound ONLY by TOX (and not TCF7)
count_only_tox <- binding_summary %>%
  filter(bound_by_TOX & !bound_by_TCF7) %>%
  summarise(unique_acr_count = n_distinct(acr_id)) %>%
  pull(unique_acr_count)

# 3. Calculate the total unique ACRs bound ONLY by TCF7 (and not TOX)
count_only_tcf7 <- binding_summary %>%
  filter(!bound_by_TOX & bound_by_TCF7) %>%
  summarise(unique_acr_count = n_distinct(acr_id)) %>%
  pull(unique_acr_count)

# --- Print the Results ---
cat("--- Summary of Unique ACRs Bound by TOX and TCF7 ---\n")
cat("Total unique ACRs bound by BOTH TOX and TCF7:", count_both_tox_tcf7, "\n")
cat("Total unique ACRs bound ONLY by TOX:", count_only_tox, "\n")
cat("Total unique ACRs bound ONLY by TCF7:", count_only_tcf7, "\n")



# Calculate the total unique acr_gene pairs bound by EITHER TOX or TCF7
count_either_tox_or_tcf7 <- binding_summary %>%
  # Filter for rows where the pair is bound by TOX OR TCF7
  filter(bound_by_TOX | bound_by_TCF7) %>%
  # Get the count of distinct acr_gene pairs
  summarise(unique_count = n_distinct(acr_id)) %>%
  # Extract the final numerical value
  pull(unique_count)

# --- Print the Result ---
cat("--- Summary of Unique ACR-Gene Pairs ---\n")
cat("Total unique pairs bound by EITHER TOX or TCF7:", count_either_tox_or_tcf7, "\n")

# For verification, this number should equal the sum of the three categories
# ('only TOX', 'only TCF7', and 'both') 
verification_total <- count_only_tox + count_only_tcf7 + count_both_tox_tcf7
cat("Verification by summing previous counts:", verification_total, "\n")





# ---- Permutation test of TOX and TCF7 binding at enhancers relative to all ATAC peaks----

# Load all ATAC peaks as background "universe"
acr_annot <- fread(file.path(bulk_atac_dir, "all_acrs_HOMER_annotated.txt")) %>%
  rename_with(~ gsub(" ", "_", .)) %>%
  mutate(acr_id = paste0(Chr, "_", Start, "_", End)) %>%
  select(acr_id, Chr, Start, End) %>%
  distinct()



all_acrs_gr <- makeGRangesFromDataFrame(acr_annot,
                                        seqnames.field = "Chr",
                                        start.field = "Start",
                                        end.field = "End")


# --- TF peaks ---
tf_groups <- c("TOX_Acute", "TCF7_Acute")

tf_peaks_gr_list <- lapply(tf_groups, function(tf) {
  peaks_df <- comb %>%
    filter(group == tf) %>%
    # Separate peak_id into coordinates *before* creating the GRanges object
    tidyr::separate(peak_id, into = c("chr", "start", "end"), sep = "[_:-]", convert = TRUE)
  
  makeGRangesFromDataFrame(peaks_df, keep.extra.columns = TRUE)
})
names(tf_peaks_gr_list) <- tf_groups




## Define the specific regions of interest for the test
# Filter to enhancer peaks only and keep unique acr_id
enhancer_acrs_df <- binding_summary %>%
  distinct(acr_id, .keep_all = TRUE) %>%
  filter(bound_by_TCF7 == TRUE)
nrow(enhancer_acrs_df)

# Split acr_id into chr, start, end
enhancer_acrs_df <- enhancer_acrs_df %>%
  separate(acr_id, into = c("chr", "start", "end"), sep = "_", convert = TRUE)

# Make GRanges object
enhancer_acrs_gr <- makeGRangesFromDataFrame(
  enhancer_acrs_df,
  seqnames.field = "chr",
  start.field = "start",
  end.field = "end",
  keep.extra.columns = TRUE
)
length(enhancer_acrs_gr)


## Run a permutation test per TF
plan(multisession, workers = 10) 

n_perm <- 1000

results <- future_lapply(tf_groups, function(tf) {
  
  message(paste("Running permutation test for:", tf))
  
  # Get TF peaks
  tf_gr <- tf_peaks_gr_list[[tf]]
  
  # Convert to summits (midpoint of each peak, width = 1)
  summits <- resize(tf_gr,
                    width = 1,
                    fix = "center")
  
  # Permutation test
  pt <- overlapPermTest(
    A = summits,
    B = enhancer_acrs_gr,
    genome = "hg38",
    universe = all_acrs_gr,
    ntimes = n_perm,
    alternative = "greater",
    rand.func = randomizeRegions,
    rand.args = list(
      allow.overlaps = TRUE,
      per.chromosome = TRUE,
      mask = NULL
    ),
    verbose = TRUE
  )
  
  # Collect results
  data.frame(
    TF = tf,
    observed_overlaps = pt$numOverlaps$observed,
    permuted_mean     = mean(pt$numOverlaps$permuted),
    z_score           = pt$numOverlaps$zscore,
    p_value           = pt$numOverlaps$pval
  )
})

results_df <- bind_rows(results)
print(results_df)







# FISHER test of TOX and TCF7 co binding at enhancer ATAC peaks

# ---- Count unique enhancers for each TF ----
mcols(enhancer_acrs_gr)$acr_gene <- enhancer_acrs_df$acr_gene

# Find overlaps
tox_hits <- findOverlaps(tf_peaks_gr_list[["TOX_Acute"]], enhancer_acrs_gr)
tcf7_hits <- findOverlaps(tf_peaks_gr_list[["TCF7_Acute"]], enhancer_acrs_gr)

# Get the unique enhancers  bound by each TF
tox_enhancer_acr_genes <- unique(mcols(enhancer_acrs_gr)$acr_gene[subjectHits(tox_hits)])
tcf7_enhancer_acr_genes <- unique(mcols(enhancer_acrs_gr)$acr_gene[subjectHits(tcf7_hits)])

# check counts
length(tox_enhancer_acr_genes)
length(tcf7_enhancer_acr_genes)


tox_bound <- tox_enhancer_acr_genes  # character vector of acr_gene bound by TOX
tcf7_bound <- tcf7_enhancer_acr_genes  # character vector of acr_gene bound by TCF7

tox_set <- unique(tox_bound)
tcf7_set <- unique(tcf7_bound)

# Intersection and differences
both_bound <- intersect(tox_set, tcf7_set)
tox_only   <- setdiff(tox_set, both_bound)
tcf7_only  <- setdiff(tcf7_set, both_bound)


# Counts needed for the test
k_tox_total <- length(tox_set)
m_tcf7_total <- length(tcf7_set)
x_both <- length(both_bound)

# --- 3. BUILD CONTINGENCY TABLE AND RUN TEST (FIXED) ---

# The 2x2 contingency table represents these counts:
#
#                | TCF7-Bound | Not TCF7-Bound
#  --------------|------------|---------------
#    TOX-Bound   |     a      |       b
#  Not TOX-Bound |     c      |       d

a <- x_both                           # Bound by TOX AND TCF7
b <- k_tox_total - x_both             # Bound by TOX only
c <- m_tcf7_total - x_both            # Bound by TCF7 only
d <- total_enhancers - (a + b + c)    # Bound by NEITHER TF

# Create the matrix
contingency_matrix <- matrix(c(a, c, b, d), nrow = 2)

# Perform the Fisher's exact test for significant enrichment (overlap)
fisher_result <- fisher.test(contingency_matrix, alternative = "greater")


# --- 4. DISPLAY RESULTS ---

# Print the contingency table for verification
colnames(contingency_matrix) <- c("TCF7_Bound", "Not_TCF7_Bound")
rownames(contingency_matrix) <- c("TOX_Bound", "Not_TOX_Bound")
print("Contingency Table:")
print(contingency_matrix)

# Print the test result
print(fisher_result)

# Print individual counts for verification
cat("\n--- Set Counts ---\n")
cat("TOX only:", length(tox_only), "\n")
cat("TCF7 only:", length(tcf7_only), "\n")
cat("Both (Intersection):", x_both, "\n")
cat("Total bound by either (Union):", length(union(tox_set, tcf7_set)), "\n")
cat("Total enhancers in background set (N):", total_enhancers, "\n")











#### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### ####
#### Figure 4 ####
#### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### ####

# Define dirs
python_output_dir <- "/Users/rileymullins/Documents/Acute_v_Chronic_Data"
output_dir <- file.path(python_output_dir, "STEP_4_output_deseq2_peak_analysis_ACUTE_ONLY")
bulk_rna_dir <- file.path(output_dir, "wherry_bulk_rna_seq_analysis")
bulk_atac_dir <- file.path(output_dir, "wherry_bulk_atac_analysis")
bzip_results_outdir <- file.path(bulk_atac_dir, "bZIP_combined_linear_regression")
dir.create(bzip_results_outdir, recursive = TRUE, showWarnings = FALSE)

# Load annotations (from above)
all_model_results_final<-read.csv(file = file.path(figdir,"with_promoter_genes_added_back_ALL_ACUTE_AND_CHRONIC_FILTERED_final_annotated_results_from_acr_gene_pairs_for_modeling.csv"))
all_model_results_final




#------------------------------------------------------------------------------------------------------------------
#### Make huARdb metacells ####
#------------------------------------------------------------------------------------------------------------------
# Set dir for this 
figdir <- "/Users/rileymullins/Documents/CC_Figs_08092025/figs/"


# Prepare metacell object from huARdb
# Load metadata
metadata <- read.csv("/Users/rileymullins/Documents/huARdb_CD8_Tcellatlas/huARdb_CD8_metadata.csv")
rownames(metadata) <- metadata$X
metadata$X <- NULL
metadata$barcode <- rownames(metadata)

# Add clone id
metadata$clone_id <- paste0(
  metadata$IR_VDJ_1_v_call, "_", 
  metadata$IR_VDJ_1_j_call, "_", 
  metadata$IR_VDJ_1_junction_aa, "_", 
  metadata$IR_VJ_1_v_call, "_", 
  metadata$IR_VJ_1_j_call, "_", 
  metadata$IR_VJ_1_junction_aa
)

# Load Tex metadata
texmd <- read.csv("/Users/rileymullins/Documents/huARdb_CD8_Tcellatlas/huardb_Tex_subcluster_metadata.csv")
rownames(texmd) <- texmd$X
texmd$X <- NULL
texmd$barcode <- rownames(texmd)

# Join tex metadata
metadata <- left_join(
  metadata,
  texmd,
  by = intersect(colnames(metadata), colnames(texmd))
)
head(metadata)

# View first few rows
head(metadata)
rownames(metadata) <-metadata$barcode

# Define subset criteria
tissues_of_interest <- c("PBMC", "TIL", "Lymph Node")
disease_type_of_interset <- c("Healthy","Solid tumor")
subsets <- setdiff(unique(metadata$cell_subset), c("ag_spcific")) # These skew the data.

# Filter metadata
metadata <- metadata %>% filter(disease_type     %in% disease_type_of_interset &
                                  meta_tissue_type %in% tissues_of_interest &
                                  cell_subset      %in% subsets
                                )

# Add cell_subtype_3 value to cell_subtype_4 value if NA
metadata$cell_subtype_4 <- ifelse(is.na(metadata$cell_subtype_4), metadata$cell_subtype_3, metadata$cell_subtype_4)

# Add a Cluster_names column
metadata$Cluster_names <- metadata$cell_subtype_4
unique(metadata$Cluster_names)

# Create Seturat object from 10X data. Filtered files were made in python
db <- CreateSeuratObject(counts = Read10X("/Users/rileymullins/Documents/Acute_v_Chronic_Data/STEP_4_output_deseq2_peak_analysis_ACUTE_ONLY/wherry_bulk_rna_seq_analysis/huARdb_CD8_T_cell_atlas_Healthy_SolidTumor_PBMC_TIL_ParatumorTissue_NormalTissue_LymphNode_min_ftr_per_cell_500_min_cells_per_gene_20_pct_mt_10"))

# Filter cells based on metadta filtering
cells_to_keep <- intersect(metadata$barcode, colnames(db))
db <- subset(db, cells = cells_to_keep)

# Add percent mt
db[["percent.mt"]] <- PercentageFeatureSet(object = db, pattern = "^MT-")

# Add metadata to object
db <- AddMetaData(db, metadata = metadata)

# Subset on other criteria
db <- subset(db, subset = (
  percent.mt       <= 7.5
))

# Create new Seurat object to avoid corrupted counts
db <- CreateSeuratObject(
  counts = GetAssayData(db,assay="RNA",layer="counts"),
  assay = "RNA",
  meta.data = db@meta.data
)

#  Set default assay 
DefaultAssay(db) <- "RNA"

# Add exhaustion reductions
umap <- read.csv("/Users/rileymullins/Documents/huARdb_CD8_Tcellatlas/huardb_Tex_subcluster_umap.csv")
umap <- umap %>% filter(X %in% colnames(db))
rownames(umap) <- umap$X
umap$X <- NULL

# Add tex umap
db[["umaptex"]] <- CreateDimReducObject(embeddings = as.matrix(umap), key = "UMAPtex_")


# Add full reductions
umap <- read.csv("/Users/rileymullins/Documents/huARdb_CD8_Tcellatlas/huARdb_CD8_umap.csv")
umap <- umap %>% filter(X %in% colnames(db))
rownames(umap) <- umap$X
umap$X <- NULL

# Add full umap
db[["umap"]] <- CreateDimReducObject(embeddings = as.matrix(umap), key = "UMAP_")


# Set Idents and define levels
# Original full list of cluster levels
full_levels <- c(
  "Tn", "Early Tcm/Tem", "Tcm", "GZMK+ Tem", "GNLY+ Temra", "CMC1+ Temra", 
  "ZNF683+ Teff", "MAIT", "ILTCK", "MACF1+ T", "CREM+ Trm", "ITGB2+ Trm", 
  "ITGAE+ Trm", "Tpex", "GZMK+ Tex", "XBP1+ Tex", "ITGAE+ Tex", "S100A11+ Tex", 
  "GZMK+ Tex ISG+", "ITGAE+ Tex IL7R+", "ITGAE+ Tex ISG+", "GZMK+ Tex IL7R+", 
  "GZMK+ Tex TNFRSF9+", "ITGAE+ Tex DUSP1+", "GZMK+ Tex DUSP1+", "Cycling T"
)

# tex clusters
tex_levels <- intersect(full_levels, unique(db$cell_subtype_4))
db$cell_subtype_4 <- factor(db$cell_subtype_4, levels = tex_levels)
Idents(db) <- db$cell_subtype_4

# broad clusters
broad_levels <- intersect(full_levels, unique(db$cell_subtype_3))
db$cell_subtype_3 <- factor(db$cell_subtype_3, levels = broad_levels)
Idents(db) <- db$cell_subtype_3

# Cluster_names
cluster_levels <- intersect(full_levels, unique(db$Cluster_names))
db$Cluster_names <- factor(db$Cluster_names, levels = cluster_levels)
Idents(db) <- db$Cluster_names


# Save
#qsave(db,file.path(figdir,"huARdb_Full_scRNA_mt7.5_full_and_tex_subclustering_umap_and_metadata.rds"))
db<-qread(file.path(figdir,"huARdb_Full_scRNA_mt7.5_full_and_tex_subclustering_umap_and_metadata.rds"))

# Make metacell object
library(Seurat)
library(tidyverse)
library(cowplot)
library(patchwork)
library(WGCNA)
library(hdWGCNA)

allowWGCNAThreads(nThreads = 12)

# Run this for metacells to work. Not actually used
db@misc[["active_wgcna"]] <- NULL # Remove if present
db@misc[["metacell"]] <-NULL # Remove if present
gc()

db <- SetupForWGCNA(
  db,
  wgcna_name = "metacell",
  features = "TOX"
)

# Remove data layer and intermediate objects to save on RAM
db@assays$RNA$data <- NULL
rm(metadata,texmd,umap)
gc()


# Make metacells
db<-MetacellsByGroups(
  db,
  group.by = c("Cluster_names"),
  ident.group = "Cluster_names",
  k = 15, # Number of cells per metacell
  reduction = "umap",
  assay = "RNA",
  slot = "counts",
  layer = "counts",
  mode = "sum",
  min_cells = 50,
  max_shared = 5,
  target_metacells = 1000000,
  max_iter = 5000,
  verbose = T
)

# Save single cell object
#qsave(db,file.path(figdir,"huARdb_filtered_with_metacells_scRNA_mt7.5_full_and_tex_subclustering_umap_and_metadata.rds"))
#db<-qread(file.path(figdir,"huARdb_filtered_with_metacells_scRNA_mt7.5_full_and_tex_subclustering_umap_and_metadata.rds"))


# Extract and normalize metacell object
metacell <- db@misc[["metacell"]][["wgcna_metacell_obj"]]

# Define full cluster levels
full_levels <- c(
  "Tn", "Early Tcm/Tem", "Tcm", "GZMK+ Tem", "GNLY+ Temra", "CMC1+ Temra", 
  "ZNF683+ Teff", "MAIT", "ILTCK", "MACF1+ T", "CREM+ Trm", "ITGB2+ Trm", 
  "ITGAE+ Trm", "Tpex", "GZMK+ Tex", "XBP1+ Tex", "ITGAE+ Tex", "S100A11+ Tex", 
  "GZMK+ Tex ISG+", "ITGAE+ Tex IL7R+", "ITGAE+ Tex ISG+", "GZMK+ Tex IL7R+", 
  "GZMK+ Tex TNFRSF9+", "ITGAE+ Tex DUSP1+", "GZMK+ Tex DUSP1+", "Cycling T"
)
cluster_levels <- intersect(full_levels, unique(metacell$Cluster_names))
metacell$Cluster_names <- factor(metacell$Cluster_names, levels = cluster_levels)
Idents(metacell) <- metacell$Cluster_names
unique(Idents(metacell))

# Make a broad clusters level
# Map function for broad clusters
metacell$broad_clusters <- metacell$Cluster_names  # start with original names
metacell$broad_clusters <- as.character(metacell$broad_clusters)  # ensure character

# Collapse Tex subclusters
metacell$broad_clusters[grep("^GZMK.*Tex", metacell$broad_clusters)]   <- "GZMK+ Tex"
metacell$broad_clusters[grep("^XBP1.*Tex", metacell$broad_clusters)]   <- "XBP1+ Tex"
metacell$broad_clusters[grep("^ITGAE.*Tex", metacell$broad_clusters)]  <- "ITGAE+ Tex"

# Convert back to factor with full levels
broad_levels <- intersect(full_levels, unique(metacell$broad_clusters))
metacell$broad_clusters <- factor(metacell$broad_clusters, levels = broad_levels)


# Save object
#qsave(metacell,file.path(figdir,"huARdb_filtered_metacell_object_hdWGCNA_Function_MetacellsByGroups_k15_mincells50_maxshared5_sum_counts_groupbyCluster_names.rds"))
#metacell <- qread(file.path(figdir,"huARdb_filtered_metacell_object_hdWGCNA_Function_MetacellsByGroups_k15_mincells50_maxshared5_sum_counts_groupbyCluster_names.rds"))
rm(db)
gc()


#------------------------------------------------------------------------------------------------------------------
#### Run propr based regulon assignment on huARdb Exh data ####
#------------------------------------------------------------------------------------------------------------------

# Define file path and load metacell object
metacell <- qread("/Users/rileymullins/Documents/CC_Figs_08092025/figs/huARdb_Full_NMF_Regulon_Analysis/huARdb_filtered_metacell_object_hdWGCNA_Function_MetacellsByGroups_k15_mincells50_maxshared5_sum_counts_groupbyCluster_names.rds")

# Load tf to gene assignments
all_model_results_final<-read.csv(file = file.path(figdir,"with_promoter_genes_added_back_ALL_ACUTE_AND_CHRONIC_FILTERED_final_annotated_results_from_acr_gene_pairs_for_modeling.csv"))

# Make a list of genes from all model results for each TF (TOX_Acute etc.) named after the TF minus "_Acute"/"_Chronic"
tf_cols <- grep("_Acute$|_Chronic$", colnames(all_model_results_final), value = TRUE)

# This list will hold the gene list for each TF
tf_gene_lists <- list()

# Loop through each TF column to extract its associated genes
for (tf_column_name in tf_cols) {
  
  # Create a cleaner name for the list by removing the "_Acute" or "_Chronic" suffix
  new_list_name <- sub("_Acute|_Chronic", "", tf_column_name)
  
  # Filter the data frame:
  # - Find rows where the current TF column has a value of 1
  # - From those rows, get the 'gene' values
  # - Remove ribosomal genes
  genes <- unique(all_model_results_final$gene[all_model_results_final[[tf_column_name]] == 1])
  genes <- genes[!grepl("^RPS|^RPL", genes)]
  
  # Combine with existing genes if this TF already has genes from another condition
  if (new_list_name %in% names(tf_gene_lists)) {
    tf_gene_lists[[new_list_name]] <- unique(c(tf_gene_lists[[new_list_name]], genes))
  } else {
    tf_gene_lists[[new_list_name]] <- genes
  }
}

names(tf_gene_lists)

# Convert the 'tf_gene_lists' object into a two-column data frame of TF-gene pairs
list_of_dfs <- lapply(names(tf_gene_lists), function(tf) {
  data.frame(
    TF = tf,
    gene = tf_gene_lists[[tf]],
    stringsAsFactors = FALSE
  )
})
tf_gene_pairs_for_modeling <- do.call(rbind, list_of_dfs)

# Keep only pairs where both TF and gene exist in the expression matrix
initial_pair_count <- nrow(tf_gene_pairs_for_modeling)

tf_gene_pairs_for_modeling <- tf_gene_pairs_for_modeling %>%
  filter(TF %in% rownames(metacell) & gene %in% rownames(metacell)) %>% 
  distinct(TF, gene) # keep only distinct pairs

final_pair_count <- nrow(tf_gene_pairs_for_modeling)

message(sprintf(
  "Created %d pairs. After filtering for genes present in the matrix, %d pairs remain for modeling.",
  initial_pair_count,
  final_pair_count
))




# Normalize data with CLR
metacell<-NormalizeData(metacell,normalization.method = "CLR")


# Add a broadest cluster assignemnt
# Define sets
nonexh_clusters <- c("Tn", "Early Tcm/Tem", "Tcm", "GZMK+ Tem", 
                     "GNLY+ Temra", "CMC1+ Temra", "ZNF683+ Teff", 
                     "MAIT", "ILTCK", "MACF1+ T", "CREM+ Trm", 
                     "ITGB2+ Trm", "ITGAE+ Trm")

exh_clusters <- c("Tpex", "GZMK+ Tex", "XBP1+ Tex", "ITGAE+ Tex","Cycling T")

# Map broad_clusters to broadest_cluster
metacell$broadest_cluster <- ifelse(metacell$broad_clusters %in% nonexh_clusters, 
                                    "nonexh",
                                    ifelse(metacell$broad_clusters %in% exh_clusters,
                                           "exh", 
                                           NA))

# Quick check
table(metacell$broadest_cluster, metacell$broad_clusters)


# Define function to calculate rho from centered log ratio
rho_p_single <- function(Ai, Aj) {
  var_sum <- var(Ai, na.rm = TRUE) + var(Aj, na.rm = TRUE)
  if (is.na(var_sum) || var_sum == 0) return(NA_real_)
  1 - (var(Ai - Aj, na.rm = TRUE) / var_sum)
}


# Define broader function for full calculation on genes with option p value
# compute_rho_p_with_pval_refactored
# - can skip p-value calculation via compute_pval = FALSE
# - accepts expr_override for a pre-subset matrix (genes x cells)
compute_rho_p_with_pval_refactored <- function(metacell = NULL,
                                               expr_override = NULL,
                                               pairs_df,
                                               assay = NULL,
                                               slot = "data",
                                               nperm = 1000,
                                               alternative = c("two.sided", "greater", "less"),
                                               seed = NULL,
                                               ncores = 1,
                                               adjust.method = "BH",
                                               compute_pval = TRUE) {

  alternative <- match.arg(alternative)

  # Decide which expression matrix to use
  if (!is.null(expr_override)) {
    expr <- as.matrix(expr_override)
  } else {
    if (is.null(metacell)) stop("Either 'metacell' or 'expr_override' must be provided.")
    if (is.null(assay)) assay <- DefaultAssay(metacell)
    expr <- as.matrix(GetAssayData(metacell, assay = assay, slot = slot))
  }

  # Validate pairs_df
  pairs_df <- as.data.frame(pairs_df, stringsAsFactors = FALSE)
  if (!all(c("TF", "gene") %in% colnames(pairs_df))) {
    stop("pairs_df must have columns named 'TF' and 'gene'.")
  }
  pairs_df$TF   <- as.character(pairs_df$TF)
  pairs_df$gene <- as.character(pairs_df$gene)

  # Filter to pairs present in expr
  present_mask <- pairs_df$TF %in% rownames(expr) & pairs_df$gene %in% rownames(expr)
  message(sprintf("Input pairs: %d, usable pairs: %d.", nrow(pairs_df), sum(present_mask)))
  pairs_df <- pairs_df[present_mask, , drop = FALSE]
  if (nrow(pairs_df) == 0) stop("No pairs remain after filtering.")

  # Worker function
  process_pair_worker <- function(ii, .pairs_df) {
    tf   <- .pairs_df$TF[ii]
    gene <- .pairs_df$gene[ii]
    Ai   <- as.numeric(expr[tf, ])
    Aj   <- as.numeric(expr[gene, ])

    obs_rho <- rho_p_single(Ai, Aj)
    if (is.na(obs_rho)) {
      return(list(TF = tf, gene = gene, rho_p = NA_real_, pvalue = NA_real_))
    }

    if (!compute_pval) {
      return(list(TF = tf, gene = gene, rho_p = obs_rho, pvalue = NA_real_))
    }

    # p-value calculation
    var_sum <- var(Ai, na.rm = TRUE) + var(Aj, na.rm = TRUE)
    perm_rhos <- vapply(seq_len(nperm), function(k) {
      perm_Aj <- Aj[perm_idx[, k]]
      1 - (var(Ai - perm_Aj, na.rm = TRUE) / var_sum)
    }, numeric(1))

    if (alternative == "greater") {
      pval <- (sum(perm_rhos >= obs_rho, na.rm = TRUE) + 1) / (nperm + 1)
    } else if (alternative == "less") {
      pval <- (sum(perm_rhos <= obs_rho, na.rm = TRUE) + 1) / (nperm + 1)
    } else {
      pval <- (sum(abs(perm_rhos) >= abs(obs_rho), na.rm = TRUE) + 1) / (nperm + 1)
    }

    list(TF = tf, gene = gene, rho_p = obs_rho, pvalue = pval)
  }

  # Pre-generate permutations if needed
  if (compute_pval) {
    ncells <- ncol(expr)
    if (!is.null(seed)) set.seed(seed)
    perm_idx <- replicate(nperm, sample.int(ncells))
  }

  # Parallel or sequential execution
  if (ncores > 1 && nrow(pairs_df) > 1) {
    message(sprintf("Running in parallel with %d cores...", ncores))
    cl <- makeCluster(ncores)
    on.exit(stopCluster(cl), add = TRUE)
    export_vars <- c("rho_p_single", "expr")
    if (compute_pval) export_vars <- c(export_vars, "perm_idx", "nperm", "alternative")
    clusterExport(cl, varlist = export_vars, envir = environment())
    res_list <- parLapplyLB(cl, seq_len(nrow(pairs_df)), process_pair_worker, .pairs_df = pairs_df)
  } else {
    message("Running sequentially...")
    res_list <- lapply(seq_len(nrow(pairs_df)), process_pair_worker, .pairs_df = pairs_df)
  }

  # Assemble results
  results_df <- data.frame(
    TF     = vapply(res_list, `[[`, character(1), "TF"),
    gene   = vapply(res_list, `[[`, character(1), "gene"),
    rho_p  = vapply(res_list, `[[`, numeric(1),   "rho_p"),
    pvalue = vapply(res_list, `[[`, numeric(1),   "pvalue"),
    stringsAsFactors = FALSE
  )

  if (compute_pval) {
    results_df$p_adj <- p.adjust(results_df$pvalue, method = adjust.method)
  }

  message("Done.")
  return(results_df)
}


# Define genes to use
needed_genes <- unique(c(tf_gene_pairs_for_modeling$TF, tf_gene_pairs_for_modeling$gene))
available_genes <- rownames(GetAssayData(metacell, slot = "data"))
needed_genes <- intersect(needed_genes, available_genes)
message(sprintf("Number of genes kept for analysis: %d", length(needed_genes)))


# 1. Run per broad_clusters
cell_types <- unique(metacell$broad_clusters)

results_by_cluster <- lapply(cell_types, function(ct) {
  message("Processing Cluster: ", ct)
  cells_ct <- colnames(metacell)[metacell$broad_clusters == ct]

  expr_ct <- as.matrix(GetAssayData(metacell, slot = "data"))[needed_genes, cells_ct, drop = FALSE]

  df <- compute_rho_p_with_pval_refactored(
    metacell = NULL,
    expr_override = expr_ct,
    pairs_df = tf_gene_pairs_for_modeling,
    nperm = 1000,
    ncores = 5,
    seed = 123,
    alternative = "two.sided",
    adjust.method = "BH",
    compute_pval = FALSE  
  )
  df$Cluster <- ct
  return(df)
})

results_all_clusters <- do.call(rbind, results_by_cluster)



# 2. Run per broadest_cluster
cell_types <- unique(metacell$broadest_cluster)

results_broadest_clusters <- lapply(cell_types, function(ct) {
  message("Processing Cluster: ", ct)
  cells_ct <- colnames(metacell)[metacell$broadest_cluster == ct]

  expr_ct <- as.matrix(GetAssayData(metacell, slot = "data"))[needed_genes, cells_ct, drop = FALSE]

  df <- compute_rho_p_with_pval_refactored(
    metacell = NULL,
    expr_override = expr_ct,
    pairs_df = tf_gene_pairs_for_modeling,
    nperm = 1000,
    ncores = 5,
    seed = 123,
    alternative = "two.sided",
    adjust.method = "BH",
    compute_pval = FALSE  # skip permutation/p-value to save memory
  )
  df$Cluster <- ct
  return(df)
})

results_broadest_clusters <- do.call(rbind, results_broadest_clusters)


# 3. Run across all clusters together
all_cells <- colnames(metacell)
expr_all <- as.matrix(GetAssayData(metacell, slot = "data"))[needed_genes, all_cells, drop = FALSE]

results_all_together <- compute_rho_p_with_pval_refactored(
  metacell = NULL,
  expr_override = expr_all,
  pairs_df = tf_gene_pairs_for_modeling,
  nperm = 1000,
  ncores = 5,
  seed = 123,
  alternative = "two.sided",
  adjust.method = "BH",
  compute_pval = FALSE
)
results_all_together$Cluster <- "All"


# 4. Combine cluster-specific and overall results
results_combined <- rbind(results_all_clusters, results_all_together,results_broadest_clusters)


# Filter for exh and non exh groupings
results_final <- results_combined %>% 
  filter(Cluster %in% c("exh","nonexh")) %>%
  filter(abs(rho_p) > 0.15) %>% 
  mutate(abs_rhop = abs(rho_p)) %>%
  mutate(Cluster = factor(Cluster,levels=c("nonexh","exh")))

table(results_final$TF)
unique(results_final$Cluster)

# Summarize number of clusters where each TF-gene pair is "significant"
tf_gene_summary <- results_final %>%
  group_by(TF, gene) %>%
  dplyr::summarise(
    n_significant_clusters = dplyr::n(),                       
    clusters = paste(unique(Cluster), collapse = ";"),     
    mean_abs_rho = mean(abs_rhop, na.rm = TRUE),               
    max_abs_rho  = max(abs_rhop, na.rm = TRUE)           
  ) %>%
  ungroup() %>%
  arrange(desc(n_significant_clusters), desc(mean_abs_rho)) 



# Create a lookup table for TF-gene-condition
tf_gene_condition <- lapply(tf_cols, function(tf_col) {
  condition <- ifelse(grepl("_Acute$", tf_col), "Acute", "Chronic")
  tf_name <- sub("_Acute|_Chronic", "", tf_col)
  genes <- unique(all_model_results_final$gene[all_model_results_final[[tf_col]] == 1])
  genes <- genes[!grepl("^RPS|^RPL", genes)]
  if(length(genes) == 0) return(NULL)
  data.frame(
    TF = tf_name,
    gene = genes,
    Condition = condition,
    stringsAsFactors = FALSE
  )
})

# Combine list into one data frame
tf_gene_condition <- do.call(rbind, tf_gene_condition)

# Create empty columns in results_final
results_final$Acute <- 0
results_final$Chronic <- 0

# Fill Acute = 1
acute_pairs <- tf_gene_condition %>% dplyr::filter(Condition == "Acute")
results_final$Acute[match(paste(acute_pairs$TF, acute_pairs$gene),
                           paste(results_final$TF, results_final$gene))] <- 1

# Fill Chronic = 1
chronic_pairs <- tf_gene_condition %>% dplyr::filter(Condition == "Chronic")
results_final$Chronic[match(paste(chronic_pairs$TF, chronic_pairs$gene),
                             paste(results_final$TF, results_final$gene))] <- 1



# Remove pairs that have opposite direction of rho in exh and nonexh
flip_pairs <- results_final %>%
  filter(Cluster %in% c("nonexh", "exh")) %>%
  group_by(TF, gene) %>%
  summarise(
    nonexh_rho = mean(rho_p[Cluster == "nonexh"], na.rm = TRUE),
    exh_rho    = mean(rho_p[Cluster == "exh"], na.rm = TRUE),
    .groups = "drop"
  ) %>%
  filter(sign(nonexh_rho) != sign(exh_rho)) %>%
  select(TF, gene)

results_final <- results_final %>%
  anti_join(flip_pairs, by = c("TF", "gene"))

# Quick check
dim(results_final)


# Make TF-gene lists

# Create two lists based on rho sign
tf_gene_lists <- results_final %>%
  group_by(TF) %>%
  dplyr::summarise(
    pos_genes = list(unique(gene[rho_p > 0])),
    neg_genes = list(unique(gene[rho_p < 0])),
    .groups = "drop"
  )

# Convert to named lists with _pos / _neg suffix
regulon_list <- list()

for(i in seq_len(nrow(tf_gene_lists))) {
  tf_name <- tf_gene_lists$TF[i]
  if(length(tf_gene_lists$pos_genes[[i]]) > 0) {
    regulon_list[[paste0(tf_name, "_pos")]] <- tf_gene_lists$pos_genes[[i]]
  }
  if(length(tf_gene_lists$neg_genes[[i]]) > 0) {
    regulon_list[[paste0(tf_name, "_neg")]] <- tf_gene_lists$neg_genes[[i]]
  }
}

# Check example
names(regulon_list)







#------------------------------------------------------------------------------------------------------------------
#### Add regulons as module score ####
#------------------------------------------------------------------------------------------------------------------
library(UCell)
# Revert data layer to standard normalization
metacell<-NormalizeData(metacell)

# Use UCell to add module score to metacells
metacell <- AddModuleScore_UCell(metacell, features=regulon_list, name = "",ncores = 7, slot="data")




#------------------------------------------------------------------------------------------------------------------
#### Positive Regulon Heatmap ####
#------------------------------------------------------------------------------------------------------------------

# Set idents
order <- c(
  "Tn",  "Tcm", "Early Tcm/Tem","GZMK+ Tem", "GNLY+ Temra", "CMC1+ Temra", 
  "ZNF683+ Teff", "MAIT", "ILTCK", "MACF1+ T", "CREM+ Trm", "ITGB2+ Trm", 
  "ITGAE+ Trm", "Tpex", "GZMK+ Tex", "XBP1+ Tex", "ITGAE+ Tex", "S100A11+ Tex", 
  "GZMK+ Tex ISG+", "ITGAE+ Tex IL7R+", "ITGAE+ Tex ISG+", "GZMK+ Tex IL7R+", 
  "GZMK+ Tex TNFRSF9+", "ITGAE+ Tex DUSP1+", "GZMK+ Tex DUSP1+", "Cycling T"
)

Idents(metacell) <- factor(Idents(metacell),levels=order)
metacell@meta.data$Cluster_names<- factor(metacell@meta.data$Cluster_names,levels=order)


# Define the score columns
regulon_score_cols <- grep("_pos$",colnames(metacell@meta.data),value=T)

plot_data <- metacell@meta.data %>%
  dplyr::select(Cluster_names, all_of(regulon_score_cols))

# Average per cluster
average_scores_df <- plot_data %>%
  dplyr::group_by(Cluster_names) %>%
  dplyr::summarise(
    dplyr::across(
      all_of(regulon_score_cols), 
      \(x) mean(x, na.rm = TRUE)
    )
  ) %>%
  dplyr::ungroup()

# Convert to matrix (rows = regulons, columns = clusters)
heatmap_matrix <- average_scores_df %>%
  tibble::column_to_rownames("Cluster_names") %>%
  t() %>%
  as.matrix()
rownames(heatmap_matrix)
colnames(heatmap_matrix)

# TF expression annotation
tfs <- c("RBPJ", "SOX4", "TCF7", "TOX", "TOX2")

# Make sure expr_mat and metadata line up
expr_mat <- GetAssayData(metacell, layer = "data")
meta <- metacell@meta.data

# Reorder metadata to match expr_mat columns
meta <- meta[colnames(expr_mat), , drop = FALSE]
cell_clusters <- meta$Cluster_names

# Compute means in the correct cluster order
avg_expr_df <- sapply(order[order %in% cell_clusters], function(clust) {
  rowMeans(expr_mat[tfs, cell_clusters == clust, drop = FALSE], na.rm = TRUE)
})

# Transpose
avg_expr_df <- t(avg_expr_df) # clusters × TFs

# Align TF annotation to heatmap columns
avg_expr_df <- avg_expr_df[, tfs, drop = FALSE]

# Ensure cluster (row) order in TF expression matches heatmap cluster (column) order
avg_expr_df <- avg_expr_df[colnames(heatmap_matrix), , drop = FALSE]

# Top annotation
pal_tf <- paletteContinuous("fireworks")
col_fun_tf <- colorRamp2(seq(0, 1.5, length.out = length(pal_tf)), pal_tf)

# Make top expr mat
top_anno <- HeatmapAnnotation(
  df = as.data.frame(avg_expr_df),
  col = setNames(rep(list(col_fun_tf), ncol(avg_expr_df)), colnames(avg_expr_df)),
  simple_anno_size = unit(3, "mm"),
  annotation_name_side = "left",
  annotation_name_gp = gpar(fontsize = 10,fontface="italic"),
  show_legend = FALSE
)
legend_tf <- Legend(
  title = "Normalized TF\nExpr Counts",
  col_fun = col_fun_tf,
  at = c(0, 1.5),
  labels = c("0", "1.5"),
  direction = "vertical",
  legend_height = unit(1.5, "cm"),
  grid_width = unit(2.5, "mm"),
  title_gp = gpar(fontsize = 10,fontface="bold"),
  labels_gp = gpar(fontsize = 10)
)


# Heatmap colors
pal <- paletteContinuous("solarExtra")
col_fun <- colorRamp2(seq(0, 0.3, length.out = length(pal)), pal)


# Draw heatmap
width = unit(ncol(heatmap_matrix) * 0.7, "cm")
height = unit(nrow(heatmap_matrix) * 0.6, "cm")

# Update rownames
rownames(heatmap_matrix) <- gsub("_pos","",rownames(heatmap_matrix))



ht <- Heatmap(
  heatmap_matrix,
  top_annotation = top_anno,
  row_dend_width = unit(0.25, "cm"),
  column_dend_height = unit(0.5, "cm"),
  name = "Regulon Score",
  col = col_fun,
  cluster_rows = F,
  cluster_columns = F,
  row_dend_side = "right",
  row_names_side = "left",
  border = TRUE,
  column_names_rot = 45,
  show_row_dend = TRUE,
  show_column_dend = TRUE,
  row_title = "TF Regulon",
  row_title_gp = gpar(fontsize = 14, fontface = "bold"),
  column_title = NULL,
  row_names_gp = gpar(fontsize = 12,fontface="bold"),
  column_names_gp = gpar(fontsize = 10,fontface="bold"),
  width = width,
  height = height,
  heatmap_legend_param = list(
    legend_height = unit(1.5, "cm"),
    grid_width = unit(2.5, "mm"),
    at = c(0, 0.3),
    title = "TF Regulon\nModule Score",
    title_gp = gpar(fontsize = 10,fontface="bold"),
    labels_gp = gpar(fontsize = 8)
  )
)


# Draw and save
ComplexHeatmap::draw(ht,
                     heatmap_legend_side = "right",
                     annotation_legend_side = "right",
                     annotation_legend_list = list(legend_tf),
                     ht_gap = unit(0.05, "mm"),
                     legend_gap = unit(1, "mm"),
                     merge_legend = TRUE)

png(file.path(figdir,"Full_huARdb_Pos_TF_regulons.png"), width = 10, height = 6, units = "in", res = 300)

ComplexHeatmap::draw(ht,
                     heatmap_legend_side = "right",
                     annotation_legend_side = "right",
                     annotation_legend_list = list(legend_tf),
                     ht_gap = unit(0.05, "mm"),
                     legend_gap = unit(1, "mm"),
                     merge_legend = TRUE)
dev.off()

pdf(file.path(figdir,"Full_huARdb_Pos_TF_regulons.pdf"), width = 10, height = 6)
ComplexHeatmap::draw(ht,
                     heatmap_legend_side = "right",
                     annotation_legend_side = "right",
                     annotation_legend_list = list(legend_tf),
                     ht_gap = unit(0.05, "mm"),
                     legend_gap = unit(1, "mm"),
                     merge_legend = TRUE)
dev.off()





#------------------------------------------------------------------------------------------------------------------
#### Make dimplot of full object ####
#------------------------------------------------------------------------------------------------------------------
db<-qread(file.path(figdir,"huARdb_Full_scRNA_mt7.5_full_and_tex_subclustering_umap_and_metadata.rds"))


order <- c(
  "Tn",  "Tcm", "Early Tcm/Tem","GZMK+ Tem", "GNLY+ Temra", "CMC1+ Temra", 
  "ZNF683+ Teff", "MAIT", "ILTCK", "MACF1+ T", "CREM+ Trm", "ITGB2+ Trm", 
  "ITGAE+ Trm", "Tpex", "GZMK+ Tex", "XBP1+ Tex", "ITGAE+ Tex", "S100A11+ Tex", 
  "GZMK+ Tex ISG+", "ITGAE+ Tex IL7R+", "ITGAE+ Tex ISG+", "GZMK+ Tex IL7R+", 
  "GZMK+ Tex TNFRSF9+", "ITGAE+ Tex DUSP1+", "GZMK+ Tex DUSP1+", "Cycling T"
)

# Keep only clusters actually in the data
present_levels <- intersect(order, unique(db$cell_subtype_4))
db$cell_subtype_4 <- factor(db$cell_subtype_4, levels = present_levels)

# Palette matches the present levels
pal <- setNames(
  paletteDiscrete(values = present_levels, set = "circus"),
  present_levels
)


# Extract metadata and UMAP embeddings
md <- db[[]]
coords <- Embeddings(db[["umap"]])
md <- cbind(md, coords)

# Generate the plot
plot <- ggplot(md, aes(x = UMAP_1, y = UMAP_2, color = cell_subtype_4)) +
  geom_point(shape = 16, size = 0.05,alpha=0.9) +  # Solid points, no border
  scale_color_manual(values = pal) +  # Use color instead of fill
  theme_classic(base_size = 10) +
  labs(
    title = NULL,
    x = "UMAP1",
    y = "UMAP2",
    color = "Cluster"  # Legend title
  ) +
  theme(
    axis.text.x = element_text(size = 10,color="black"),
    axis.text.y = element_text(size = 10,color="black"),
    axis.title = element_text(size = 10, face = "bold",color="black"),
    axis.text = element_text(size = 10,color="black"),
    legend.text = element_text(size = 8.5,color="black"),
    legend.title = element_text(size = 8.5, face = "bold",color="black"),
    panel.grid = element_blank(),
    axis.line = element_line(linewidth = 0.3),
    legend.position = "right",
    legend.margin = margin(0, 0, 0, 0),
    legend.key.size = unit(1, "mm"),
    legend.spacing.x = unit(1, "mm"),
        legend.spacing.y = unit(1, "mm"),

    legend.key.width  = unit(1, "mm")

  ) +
  guides(
    color = guide_legend(
      ncol = 1,                
      override.aes = list(size = 2,alpha=1)  # Size of legend dots
    )
  ) +
  coord_fixed(ratio = 1, clip = "off")  # ensures panel is square

ggsave(plot,file = file.path(figdir,"DimPlot_fine_clustering_huARdb_Exh.png"),height = 4.5,width=4.5,units = "in",bg="white",dpi=300)
ggsave(plot,file = file.path(figdir,"DimPlot_fine_clustering_huARdb_Exh.pdf"),height =4,width=4,units = "in")



rm(db);gc()






#------------------------------------------------------------------------------------------------------------------
#### NMF on POSITIVE targets  ####
#------------------------------------------------------------------------------------------------------------------
library(GeneNMF)

gc()
# Filter for positive regulons for 
pos_regulons <- regulon_list[grep("_pos$", names(regulon_list))]

# Clean up previous NMF results if they exist
metacell@reductions[["NMF_UMAP"]] <- NULL
metacell@reductions[["NMF"]] <- NULL
metacell@meta.data <- metacell@meta.data[, !grepl("NMF_", colnames(metacell@meta.data))]
metacell@meta.data <- metacell@meta.data[, 1:17]

# --- Run NMF ---

nmf_genes <- unique(c(unique(unlist(pos_regulons)))) 

ndim =9
metacell <- runNMF(
  metacell,
  assay = "RNA",
  slot = "data",
  k = ndim,
  new.reduction = "NMF",
  seed = 123,
  L1 = c(0.35, 0),
  hvg = nmf_genes,
  center = T,
  scale = T
)
gc()

# --- Process NMF Results ---
# Get NMF loadings and add the suffix
nmf_loadings <- metacell@reductions[["NMF"]]@feature.loadings


# Normalize loadings
normalized_loadings <- apply(nmf_loadings, 2, function(col) {
  if (sum(col) > 0) {
    return(col / sum(col))
  } else {
    return(col)
  }
})

# Get top genes based on cumulative contribution
list_of_top_genes <- lapply(colnames(normalized_loadings), function(factor_name) {
  factor_vector <- normalized_loadings[, factor_name]
  sorted_vector <- sort(factor_vector, decreasing = TRUE)
  cumulative_sum <- cumsum(sorted_vector)
  selected_genes <- names(sorted_vector)[cumulative_sum <= 0.8]
  if (length(selected_genes) == 0 && length(sorted_vector) > 0) {
    return(names(sorted_vector)[1])
  }
  return(selected_genes)
})

# Name the list elements after the NMF factors
names(list_of_top_genes) <- colnames(normalized_loadings)
list_of_top_genes


 #Rename
programs <- list_of_top_genes

#  ---  Initialize matrix to store similarities ---
 num_programs <- length(programs)
 program_names <- names(programs)

 similarity_matrix <- matrix(0, nrow = num_programs, ncol = num_programs,
                                  dimnames = list(program_names, program_names))

#  ---Calculate pairwise Jaccard similarity ---
#  The Jaccard Index = (size of intersection) / (size of union)
 for (i in 1:num_programs) {
   for (j in i:num_programs) {
     genes1 <- programs[[i]]
     genes2 <- programs[[j]]

     intersection_size <- length(intersect(genes1, genes2))
     union_size <- length(union(genes1, genes2))

     jaccard_sim <- if (union_size > 0) intersection_size / union_size else 0

   #   Fill the matrix (it's symmetric)
     similarity_matrix[i, j] <- jaccard_sim
     similarity_matrix[j, i] <- jaccard_sim
   }
 }

#  --- Visualize with a heatmap ---
 size=40

  #Enforce scale from 0 to max_val
 breaks <- seq(0, 1, length.out = 101)

  #Use desired palette (100 colors)
 pheatmap(
   similarity_matrix,
   main = "Pairwise Similarity of NMF Programs",
   breaks = breaks,
   clustering_method = "ward.D2",
   display_numbers = round(similarity_matrix, 2),
   fontsize_number = 15,
   number_color = "white",
   cellwidth = size,
   cellheight = size
 )



# --- Scoring and Visualization ---

# Calculate module scores for NMF gene sets
metacell <- AddModuleScore_UCell(metacell, features = list_of_top_genes, name = "", ncores = 4)
# VlnPlot_scCustom(metacell,features=c(paste0("NMF_",c(1:ndim))),pt.size=0,sort=F)


# Signature score dimplot
 matrix <- metacell@meta.data[,paste0("NMF_", 1:ndim)]

 dimred <- as.matrix(matrix)
 colnames(dimred) <- paste0("NMF_",seq(1, ncol(dimred)))

 metacell@reductions[["NMFsignatures"]] <- new("DimReduc",
                                          cell.embeddings = dimred,
                                          assay.used = "RNA",
                                          key = "NMF_",
                                         global = FALSE)
 
 metacell <- RunUMAP(metacell, reduction="NMFsignatures", dims=1:length(metacell@reductions[["NMFsignatures"]]),
                metric = "euclidean", reduction.name = "umap_nmf")
 DimPlot_scCustom(metacell,label=F)
 
FeaturePlot_scCustom(metacell,features=c(paste0("NMF_",c(1:ndim))),colors_use = viridis_light_high,raster=F,pt.size=0.1)


# --- Annotation against TF Regulons ---

# Get all unique NMF top genes
all_nmf_genes <- unique(unlist(list_of_top_genes))

# Get TF names
tf_names <- names(pos_regulons)

# Prepare annotation matrix with the correct name
annotation_mat <- matrix(FALSE, nrow = length(all_nmf_genes), ncol = length(tf_names),
                              dimnames = list(all_nmf_genes, tf_names))

# Fill matrix: mark TRUE if a gene is in a regulon
for (tf in tf_names) {
  regulon_genes <- pos_regulons[[tf]]
  genes_in_both <- intersect(all_nmf_genes, regulon_genes)
  annotation_mat[genes_in_both, tf] <- TRUE
}

# Convert to a numeric data frame (0/1)
annotation_df <- as.data.frame(annotation_mat) * 1






#-------- Make vlnplot of programs ------
# Update metadata columns
for (orig_col in names(nmf_map)) {
  
  # Get the desired new column name from the map
  new_col <- nmf_map[[orig_col]]
  
  # Create the new column with the data from the original column.
  metacell@meta.data[[new_col]] <- metacell@meta.data[[orig_col]]
}



# Make color pal for nmf programs
library(viridis)
pal <- turbo(length(nmf_names))


# --- 2. Prepare data for ggplot ---
# Extract the metadata and NMF scores into a data frame
plot_data <- metacell@meta.data %>%
  select(Cluster_names, all_of(nmf_names)) # Use 'Cluster_names' or whatever is in Idents(metacell)

# Reshape the data from wide to long format
plot_data_long <- plot_data %>%
  pivot_longer(
    cols = all_of(nmf_names),
    names_to = "Program",
    values_to = "Score"
  )

# Order based on the clustering above
prog_order <- c("Stemness",
                "Terminal Effector",
                "Effector",
                "Acute Activation",
                "NFkB Signaling",
                "Exhaustion",
                "Interferon Response",
                "Cell Cycle",
                "Membrane Remodeling")
# Set factor
plot_data_long$Program <- factor(plot_data_long$Program, levels = prog_order)


# --- 3. Create the stacked violin plot ---
stacked_vln_plot <- ggplot(plot_data_long, aes(x = Cluster_names, y = Score, fill = Program)) +
  
  geom_violin(scale = "width", trim = T, show.legend = FALSE, size = 0.2, width = 0.8) +

  geom_hline(yintercept = 0, color = "black", linewidth = 0.5) +
  
  # Facet with free y-axis
  facet_grid(rows = vars(Program), scales = "free") +
  
  # Optional: ensure 0 appears in every facet
  geom_blank(aes(y = 0)) +
  
  scale_fill_manual(values = pal) +
  
  theme_classic() +
  theme(
    panel.spacing = unit(0.5, "lines"),
    strip.background = element_blank(),
    strip.text.y = element_text(size = 10, angle = 0, hjust = 0, face = "bold", color = "black"),
    axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5, size = 8, color = "black"),
    axis.text.y = element_text(size = 8, color = "black"),
    axis.title.y = element_text(size = 10, face="bold", color = "black"),
    axis.title.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.line.x = element_blank()
  ) + scale_y_continuous(breaks = breaks_width(0.2)) 

stacked_vln_plot

# Save
ggsave(stacked_vln_plot, file = file.path(figdir,"Stacked_regulon_programs_Vln_fine_clustering_huARdb_Exh.png"),
       height = 8, width = 6.5, units = "in", bg="white", dpi=300)

ggsave(stacked_vln_plot, file = file.path(figdir,"Stacked_regulon_programs_Vln_fine_clustering_huARdb_Exh.pdf"),
       height =8, width=6.5, units = "in")







#==================================================================================================================
####  Heatmap  Avg Expression per Cluster ####
#==================================================================================================================

# Load libraries
library(ComplexHeatmap)
library(circlize)
library(dplyr)
library(Matrix)

# Define cluster levels (same as above)
cluster_order <- c(
  "Tn",  "Tcm", "Early Tcm/Tem","GZMK+ Tem", "GNLY+ Temra", "CMC1+ Temra", 
  "ZNF683+ Teff", "MAIT", "ILTCK", "MACF1+ T", "CREM+ Trm", "ITGB2+ Trm", 
  "ITGAE+ Trm", "Tpex", "GZMK+ Tex", "XBP1+ Tex", "ITGAE+ Tex", "S100A11+ Tex", 
  "GZMK+ Tex ISG+", "ITGAE+ Tex IL7R+", "ITGAE+ Tex ISG+", "GZMK+ Tex IL7R+", 
  "GZMK+ Tex TNFRSF9+", "ITGAE+ Tex DUSP1+", "GZMK+ Tex DUSP1+", "Cycling T"
)
# Set levels
metacell$Cluster_names<-factor(metacell$Cluster_names,
                               levels=intersect(cluster_order,unique(metacell$Cluster_names)))

# Set idents
Idents(metacell) <- metacell$Cluster_names

# Define positive regulons
pos_regulons <- regulon_list[grep("_pos$", names(regulon_list))]


# --- Step 1: Programs, TFs, names, order ---
all_programs <- names(list_of_top_genes)

program_name_map <- setNames(nmf_names, all_programs)
final_order <- prog_order # From above in violin plot

target_tfs <- c("RBPJ_pos", "TCF7_pos", "SOX4_pos", "TOX_pos", "TOX2_pos")
tf_colors <- c("RBPJ"="#000436", "SOX4"="#1632FB", "TCF7"="#C732D5", "TOX"="#FDB31A", "TOX2"="#A31D1D")

# --- Step 2: Collect genes and build TF annotations ---
genes_to_plot <- c()
gene_program_map <- c()
tf_annotation_list <- list(RBPJ=c(), SOX4=c(), TCF7=c(), TOX=c(), TOX2=c())

for (prog in all_programs) {
  genes_in_program <- intersect(list_of_top_genes[[prog]], rownames(metacell))
  human_readable_name <- program_name_map[prog]
  genes_to_plot <- c(genes_to_plot, genes_in_program)
  gene_program_map <- c(gene_program_map, rep(human_readable_name, length(genes_in_program)))
  
  for (tf in target_tfs) {
    tf_name <- gsub("_pos", "", tf)
    is_regulated_text <- ifelse(genes_in_program %in% pos_regulons[[tf]], "Target", "Not Target")
    tf_annotation_list[[tf_name]] <- c(tf_annotation_list[[tf_name]], is_regulated_text)
  }
}

# --- Step 3: Average expression per cluster ---
expr_matrix <- GetAssayData(metacell, assay="RNA", slot="data")[genes_to_plot, ]

# Ensure columns follow the factor levels
cluster_levels <- levels(metacell$Cluster_names)
scaled_expr <- sapply(cluster_levels, function(clust) {
  cells <- WhichCells(metacell, idents = clust)
  rowMeans(expr_matrix[, cells, drop = FALSE])
})
colnames(scaled_expr) <- cluster_levels
scaled_expr <- t(scale(t(scaled_expr)))
scaled_expr[is.na(scaled_expr)] <- 0

# --- Step 3b: Top annotation for clusters ---
top_annot_df <- data.frame(
  Cluster = factor(colnames(scaled_expr), levels = cluster_levels),
  row.names = colnames(scaled_expr)
)
cluster_palette <- setNames(
  paletteDiscrete(values = cluster_levels, set = "circus"),
  cluster_levels
)


top_annotation_clusters <- HeatmapAnnotation(
  df = top_annot_df,
  col = list(Cluster = cluster_palette),
  annotation_name_gp = gpar(fontsize = 6, fontface = "bold"),
  show_annotation_name = TRUE,
  annotation_name_side = "left",
  simple_anno_size = unit(2, "mm"),
  annotation_legend_param = list(
    title = "Cluster",
    title_gp = gpar(fontsize = 5, fontface = "bold"),
    labels_gp = gpar(fontsize = 5),
    grid_height = unit(2, "mm"),
    grid_width = unit(2, "mm"),
    ncol = 1
  )
)

# --- Step 4: Row annotation for TFs and Programs (Updated) ---

# 1. Create the base data frame for TF annotations
tf_order <- c("RBPJ", "SOX4", "TCF7", "TOX", "TOX2")
row_annot_df <- as.data.frame(tf_annotation_list, stringsAsFactors = FALSE)[, tf_order]

# 2. Add the Program information as a new column to the annotation data frame
# 'gene_program_map' and 'final_order' are already defined in script
row_annot_df$Program <- factor(gene_program_map, levels = final_order)

# 3. Create the color mapping for TFs 
for(tf in tf_order) {
  row_annot_df[[tf]] <- factor(ifelse(row_annot_df[[tf]] == "Target", "Target", "Not Target"),
                                 levels = c("Target", "Not Target"))
}
tf_color_map <- lapply(tf_order, function(tf) {
  setNames(c(tf_colors[tf], "grey95"), c("Target", "Not Target"))
})
names(tf_color_map) <- tf_order

# 4. Create a new color mapping for the Programs
program_palette <- setNames(
     turbo(length(nmf_names)), 
    final_order
)

# 5. Combine all color mappings into a single list
# The names in this list MUST match the column names in 'row_annot_df'
combined_colors <- c(list(Program = program_palette), tf_color_map)

# 6. Create the final rowAnnotation object
row_annotation_all <- rowAnnotation(
  df = row_annot_df,
  col = combined_colors,
  show_annotation_name = TRUE,
  annotation_name_gp = gpar(fontsize = 6, fontface = "bold"),
  border = TRUE,
  simple_anno_size = unit(1.75, "mm"), 
  gap = unit(0.75, "mm"), 
  annotation_legend_param = list(
    title_gp = gpar(fontsize = 5, fontface = "bold"),
    labels_gp = gpar(fontsize = 5),
    grid_height = unit(2, "mm"),
    grid_width = unit(2, "mm")
  )
)

# --- Step 5: Row split by program ---
program_split <- factor(gene_program_map, levels = final_order)

# --- Step 5b: Define Manual Column Split ---
# This creates the grouping variable for splitting the heatmap columns.

# Find the position of the last "Non-Exhausted" cluster
split_index <- which(cluster_levels == "ITGAE+ Trm")

# Create a vector that assigns each column to a group
column_group_vector <- c(rep("Non-Exhausted", split_index), 
                         rep("Exhausted", length(cluster_levels) - split_index))

# Convert to a factor to ensure the desired order of the splits
column_split_groups <- factor(column_group_vector, levels = c("Non-Exhausted", "Exhausted"))

# --- Step 6: Heatmap colors ---
cols <- paletteContinuous("blueYellow")
col_fun <- colorRamp2(seq(-2, 2, length.out = length(cols)), cols)


# --- Step 7: Plot heatmap ---
ht <- Heatmap(
  scaled_expr,
  use_raster = TRUE,
  raster_quality = 10,
  name = "Z-Scaled\nExpr",
  
  # --- MODIFICATIONS FOR MANUAL SPLIT ---
  cluster_columns = FALSE,          # Keep original column order within splits
  column_split = column_split_groups, # SPLIT columns by the manual groups
  
  cluster_rows = FALSE,
  cluster_row_slices = FALSE,
  row_split = program_split,
  right_annotation = row_annotation_all,
  top_annotation = top_annotation_clusters,
  show_row_names = FALSE,
  show_column_names = FALSE,
  show_row_dend = FALSE,
  row_dend_side = "left",
  show_parent_dend_line = FALSE,
  column_gap = unit(1, "mm"),
  row_gap = unit(0.5, "mm"),
  border = TRUE,
  row_title=NULL,
  column_dend_height = unit(0, "cm"),
  row_title_gp = gpar(fontsize = 6, fontface = "bold"),
  column_title_gp = gpar(fontsize = 6, fontface = "bold"),
  col = col_fun,
  heatmap_legend_param = list(
    title = "Z-Scaled\nExpr",
    title_gp = gpar(fontsize = 5, fontface = "bold"),
    labels_gp = gpar(fontsize = 5),
    legend_height = unit(4, "mm"),
    grid_width = unit(2.5, "mm")
  )
)

# Space between heatmap and annotatin
ht_opt$ROW_ANNO_PADDING = unit(1, "mm")

# --- Step 8: Save ---
png(file.path(figdir, "huARdb_avg_pos_NMF_Program_Genes_Heatmap.png"),
    width = 5.25, height = 4.5, units = "in", res = 300)
ComplexHeatmap::draw(ht, heatmap_legend_side = "right", annotation_legend_side = "right",
     padding = unit(c(0, 0, 0, 0), "mm"),  # Set right padding to 0
     gap = unit(0.1, "mm")
)

dev.off()

pdf(file.path(figdir, "huARdb_avg_pos_NMF_Program_Genes_Heatmap.pdf"),
    width = 5.25, height = 4.5)
ComplexHeatmap::draw(ht, heatmap_legend_side = "right", annotation_legend_side = "right",
                                          gap = unit(0, "mm")) 
dev.off()

# Get proportion of genes bound by each tf 
tf_order <- c("RBPJ", "SOX4", "TCF7", "TOX", "TOX2")

proportion_bound <- row_annot_df %>%
  group_by(Program) %>%
  summarise(across(all_of(tf_order),
                   ~ mean(.x == "Target"),
                   .names = "{col}"))

proportion_bound


#
#################################################################
# Save  objects
#################################################################
dir <-"/Users/rileymullins/Documents/CC_Figs_08092025/figs/huARdb_Full_NMF_Regulon_Analysis_v2_no_gap_in_atac_peak_ol_and_+-1kb_promoter_window"
#qsave(metacell,file=file.path(dir,"v2_huARdb_filtered_metacell_with_NMF_Regulon_Scores_object_hdWGCNA_Function_MetacellsByGroups_k15_mincells50_maxshared5_sum_counts_groupbyCluster_names.rds"))
#saveRDS(regulon_list, file=file.path(dir,"v2_regulon_list_huARdb_full.rds"))
#saveRDS(list_of_top_genes, file=file.path(dir,"v2_NMF_pos_regulon_list_of_top_geneshuARdb_full.rds"))
#saveRDS(nmf_loadings, file=file.path(dir,"v2_NMF_loadings.rds"))
#write.csv(proportion_bound, file=file.path(dir,"proportion_genes_bound_by_each_tf_in_v2_NMF.csv"))

# Read object

#metacell <- qread(file=file.path(dir,"v2_huARdb_filtered_metacell_with_NMF_Regulon_Scores_object_hdWGCNA_Function_MetacellsByGroups_k15_mincells50_maxshared5_sum_counts_groupbyCluster_names.rds"))



#### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### ####
#### Figure 5 ####
#### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### ####

# Increased signal
# binned per sample data
dt <- fread("/Users/rileymullins/Documents/CC_Figs_08092025/per_sample_bin_sum_ins_old_and_new_method/combined_binned_200bp_all_samples.tsv", nThread = 10) %>% arrange(desc(count)) %>%
  filter(!chr %in%"chr2" & !bin_start %in% c("32916200","32916400","32916600"))
head(dt)

# Group by 'sample' and apply the summary() function to the 'count' column
summary_stats <- dt[, as.list(summary(count)), by = sample]

# Print the summary table to the console
print(summary_stats)

# Define the output file path
output_file <- "/Users/rileymullins/Documents/CC_Figs_08092025/per_sample_bin_sum_ins_old_and_new_method/summary_stats_by_sample.csv"

# Save the summary statistics to a new CSV file
#fwrite(summary_stats, file = output_file)

# Load the required libraries
library(data.table)
library(pheatmap)

# --- 2. Calculate Percentiles and Prepare Data ---
percentile_intervals <- seq(0, 1, by = 0.01)
percentile_stats <- dt[, as.list(quantile(count, probs = percentile_intervals)), by = sample]
setorder(percentile_stats, -`100%`)

heatmap_matrix <- as.matrix(percentile_stats[, -'sample'])
rownames(heatmap_matrix) <- percentile_stats$sample
log_heatmap_matrix <- log10(heatmap_matrix + 1)

# --- 3. Create Custom Column Labels ---
col_names <- colnames(log_heatmap_matrix)
keep_labels <- as.numeric(gsub("%", "", col_names)) %% 10 == 0
display_col_names <- ifelse(keep_labels, col_names, "")

# --- 4. Define Color Palette for ComplexHeatmap ---
data_range <- range(log_heatmap_matrix)
color_breaks <- c(
  data_range[1],
  data_range[1] + (data_range[2] - data_range[1]) * 0.25,
  data_range[1] + (data_range[2] - data_range[1]) * 0.5,
  data_range[1] + (data_range[2] - data_range[1]) * 0.75,
  data_range[2]
)
col_fun <- colorRamp2(
  breaks = color_breaks,
  colors = c("white", "#2488F0", "#7F3F98", "#E22929", "#FCB31A")
)

# --- NEW: 5. Create Row Split and Left Annotation ---
# Define the groups for the row split
num_samples <- nrow(log_heatmap_matrix)
row_split_groups <- c(rep("Barcoded", 18), rep("Standard", num_samples - 18))

# Create the left annotation
method_annotation <- rowAnnotation(
  Method = row_split_groups, # The name of the annotation and the values
  col = list(Method = c("Barcoded" = "forestgreen", "Standard" = "navy")),
  show_annotation_name = FALSE, # Hides the name "Method"
  border = TRUE,
  width = unit(1, "mm"),
  gp = gpar(fontsize = 8),
    simple_anno_size = unit(2.5, "mm"),
    annotation_legend_param = list(
    title_gp = gpar(fontsize = 8, fontface = "bold"),
    labels_gp = gpar(fontsize = 8)
  )
)



# --- 6. Create the Heatmap Object ---
ht <- Heatmap(
  matrix = log_heatmap_matrix,
  name = "log10(count+1)",
  row_title= NULL,
  col = col_fun,
  cluster_rows = FALSE,
  cluster_columns = FALSE,
  show_row_names = FALSE,
  show_column_names = TRUE,
  column_labels = display_col_names,
  border = T,
  column_title = "Insertion Count Percentile",
  column_title_side = "bottom",
  column_title_gp = gpar(fontsize = 10,fontface="bold"),
  row_gap = unit(1, "mm"),

  column_names_gp = gpar(fontsize = 10),
  row_names_gp = gpar(fontsize = 10),
  row_split = row_split_groups, # This adds the split
  right_annotation = method_annotation, # This adds the annotation
  heatmap_legend_param = list(
    title = "log10\nInsertion Count",
    title_gp = gpar(fontsize = 8,fontface="bold"),
    labels_gp = gpar(fontsize = 8)
  )
)

# --- 6. Draw the Heatmap with Main Title ---
# The 'draw' function renders the plot with the main title
ComplexHeatmap::draw(
  ht,
  heatmap_legend_side = "right"
)

png("/Users/rileymullins/Documents/CC_Figs_08092025/per_sample_bin_sum_ins_old_and_new_method/insertions_by_percentile_per_sample_heatmap.png", width = 4, height = 4, units = "in", res = 300)
# The 'draw' function renders the plot with the main title
ComplexHeatmap::draw(
  ht,
  heatmap_legend_side = "right"
)
dev.off() # Close the PNG device

pdf("/Users/rileymullins/Documents/CC_Figs_08092025/per_sample_bin_sum_ins_old_and_new_method/insertions_by_percentile_per_sample_heatmap.pdf", width = 4, height = 4)
# The 'draw' function renders the plot with the main title
ComplexHeatmap::draw(
  ht,
  heatmap_legend_side = "right"
)
dev.off() # Close the PNG device




# Signal to noise ratio
summary_metrics <- dt[, list(
  median_ratio = {
    q_vals <- quantile(count, probs = c(0.2, 0.8))
    top_median <- mean(count[count >= q_vals[2]])
    bottom_median <- mean(count[count <= q_vals[1]])
    top_median / (bottom_median + 1e-6)
  }
), by = sample]

# --- 2. Sort the data and add a grouping variable for color ---
setorder(summary_metrics, -median_ratio)
summary_metrics[, method_group := c(rep("Barcoded", 18), rep("Standard", .N - 18))]
summary_metrics$method_group <- factor(summary_metrics$method_group, levels=c("Standard","Barcoded"))
p<- ggplot(summary_metrics, aes(x = method_group, y = median_ratio)) +
  geom_violin(
    aes(fill = method_group),
    color = "black",
    trim = FALSE,
    alpha = 0.5,
    width = 1
  ) +
  geom_jitter(
    aes(color = method_group),
    width = 0.1,
    size = 2,
    shape=16,
    alpha = 0.8
  ) +
  scale_fill_manual(
    values = c("Barcoded" = "forestgreen", "Standard" = "navy")
  ) +
  scale_color_manual(
    values = c("Barcoded" = "forestgreen", "Standard" = "navy")
  ) +
  labs(
    title =NULL,
    x = "Method",
    y = "Top 20th / Bottom 20th Percentile\nMean Counts",
    fill = "Method",
    color = "Method"
  ) +
theme_minimal(base_size = 10) +
  theme(
    text = element_text(color = "black", size = 10),
    axis.title.x = element_text(color = "black", size = 11, face = "bold"),
    axis.title.y = element_text(color = "black", size = 11, face = "bold"),
    axis.text = element_text(color = "black", size = 10),
    axis.line = element_line(color = "black"),  # add axis lines
    panel.grid = element_blank(),               # remove all grid lines
    legend.title = element_text(color = "black", size = 10, face = "bold"),
    legend.text = element_text(color = "black", size = 10),
    plot.title = element_text(color = "black", size = 10)
  )
p
ggsave(p,file="/Users/rileymullins/Documents/CC_Figs_08092025/per_sample_bin_sum_ins_old_and_new_method/signal-to-noise_ratio_vln.png", width = 4, height = 4,bg="white")
ggsave(p,file="/Users/rileymullins/Documents/CC_Figs_08092025/per_sample_bin_sum_ins_old_and_new_method/signal-to-noise_ratio_vln.pdf", width = 4, height = 4)




# Removed cap on signal
# Calculate max signal per sample
dt_max <- dt[, .(max_count = max(count)), by = sample]

# Add method grouping
dt_max[, method_group := method_lookup[sample]]

# Summary statistics
dt_stats <- dt_max[, .(
  mean_max = mean(max_count),
  median_max = median(max_count),
  max_max = max(max_count)
), by = method_group]

print("Summary statistics:")
print(dt_stats)

# Simple scatter plot with per-group median lines
p <- ggplot(dt_max, aes(x = method_group, y = max_count, color = method_group)) +
  geom_jitter(width = 0.4, height = 0, alpha = 0.8, size = 2,shape=16) +
  # Dashed horizontal line at fixed y = 112 across all groups
  geom_hline(yintercept = 112, linetype = "dashed", size = 0.5, color = "black") +
  scale_color_manual(values = c("Standard" = "navy", "Barcoded" = "forestgreen")) +
  labs(
    x = "Method",
    y = "Maximum Signal Detected per Sample",
    color = "Method",
    title = NULL
  ) +
  theme_minimal(base_size = 10) +
  theme(
    text = element_text(color = "black", size = 10),
    axis.title.x = element_text(color = "black", size = 11, face = "bold"),
    axis.title.y = element_text(color = "black", size = 11, face = "bold"),
    axis.text = element_text(color = "black", size = 10),
    axis.line = element_line(color = "black"),
    panel.grid = element_blank(),
    legend.title = element_text(color = "black", size = 10, face = "bold"),
    legend.text = element_text(color = "black", size = 10),
    plot.title = element_text(color = "black", size = 10)
  )+ylim(0,1200)

print(p)


# Add summary statistics as text
dt_stats <- dt_max[, .(
  mean_max = mean(max_count),
  median_max = median(max_count),
  max_max = max(max_count)
), by = method_group]

print("Summary statistics:")
print(dt_stats)

# Save plot
ggsave(p, file = "/Users/rileymullins/Documents/CC_Figs_08092025/per_sample_bin_sum_ins_old_and_new_method/max_signal_per_sample.png", 
       width = 4, height = 4, bg = "white", dpi = 300)
# Save plot
ggsave(p, file = "/Users/rileymullins/Documents/CC_Figs_08092025/per_sample_bin_sum_ins_old_and_new_method/max_signal_per_sample.pdf", 
       width = 4, height = 4, bg = "white", dpi = 300)

print(p)





#---------------------------------------------------------
# Peak analysis
#---------------------------------------------------------
# Define paths
all_sig_file <- "/Users/rileymullins/Documents/20250602_5BC_Exp9_V5_results/full_dataset_without_pool2/STEP_4_output_deseq2_peak_analysis/HOMER_annotations_COMBINED_all_Group_vs_Control_results.csv"
output_dir <- "/Users/rileymullins/Documents/CC_Figs_08092025/synTF_Fig6"

# Load specific peaks
specific_peaks <-read.csv("/Users/rileymullins/Documents/20250602_5BC_Exp9_V5_results/full_dataset_without_pool2/STEP_4_output_deseq2_peak_analysis/group_specific_peaks_summary.csv")

# Load all data
all_sig <- read.csv(all_sig_file)



# Plot peaks and specific peaks as a stacked bar plot 
group_order_plots = c("JUN","FOSL1","BATF","JUN.FOS.BATF", "FOSL1.BATF.MAFA","BATF3.BATF2.MAFF",
                                                                "BATF3.JDP2.BATF2","MAFF.ATF3.BATF2"
                                                                )

# Merge all_sig with specific_peaks info
merged_df <- all_sig %>%
  left_join(
    specific_peaks %>%
      select(peak_id, specific_for_group),
    by = "peak_id"
  ) %>%
  mutate(
    specific_flag = ifelse(
      !is.na(specific_for_group) & group == specific_for_group,
      "True",
      "False"
    ),
    group = factor(group, levels = group_order_plots)
  )

# Count peaks by group and specificity
counts_specific <- merged_df %>%
  dplyr::count(group, specific_flag, name = "num_peaks")

# Turbo palette (two colors: specific vs not specific)
palette_colors <- c("navy","grey90")
counts_specific$specific_flag <- factor(counts_specific$specific_flag, levels=c("True", "False"))

# Stacked bar plot
p <- ggplot(counts_specific, aes(x = group, y = num_peaks, fill = specific_flag)) +
  geom_bar(stat = "identity", color = "black", linewidth = 0.25,width = 0.5) +
  scale_fill_manual(values = palette_colors) +
  labs(
    x = NULL,
    y = "Peak Count",
    fill = "Specific to TF"
  ) + 
  theme_minimal(base_size = 12) +
  theme(
    text = element_text(color = "black"),
    plot.title = element_text(hjust = 0.5, face = "bold"),
    axis.title.y = element_text(face = "bold"),
    axis.text = element_text(face = "bold", color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
    axis.line = element_line(color = "black", size = 0.5),
    axis.ticks = element_line(color = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.background = element_blank(),
    legend.title = element_text(face = "bold", color = "black", size="8"),
    plot.background = element_blank(),
      legend.margin = margin(0, 0, 0, 0),
  legend.key.height = unit(0.25, "cm"),
  legend.spacing.x = unit(0.25, "cm"),
  legend.key.width = unit(0.25, "cm"),
    legend.position = "right"
  )+scale_y_continuous(expand = c(0, 0), limits = c(0,15000))

p


# Save as .png
ggsave(file = file.path(output_dir,"Total_Peaks_per_Condition_Plot.png"), plot = p, width = 5, height = 2.5, bg="white",dpi = 300)

# Save as .pdf
ggsave(file = file.path(output_dir,"Total_Peaks_per_Condition_Plot.pdf"), plot = p, width = 5, height =2.5)





#### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### ####
#### Figure 6 ####
#### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### ####


# Motif Plot of HOMER Motif Results ----
# Define directory and find HOMER output files
motif_result_files <- list.files(
  "/Users/rileymullins/Documents/20250602_5BC_Exp9_V5_results/full_dataset_without_pool2/STEP_4_output_deseq2_peak_analysis/HOMER/HOMER_motif_analysis",
  pattern     = "knownResults.txt",
  recursive   = TRUE,
  full.names  = TRUE
)

# A more memory-efficient way to load and combine the data
motif_results_list <- lapply(motif_result_files, function(file) {
  
  # Use data.table::fread 
  dt <- data.table::fread(
    file,
    select = c(
      "Motif Name",
      "P-value",
      "Log P-value",
      "q-value (Benjamini)",
      "% of Target Sequences with Motif",
      "% of Background Sequences with Motif"
    )
  )
  
  # Create the group name from the file's directory
  group <- basename(dirname(file)) %>%
    str_remove("_motif_output$") %>%
    str_trim()
  
  # Add the group name as a new column
  dt[, group_name := group]
  
  return(dt)
})

# Combine the list of data.tables into a single one using the efficient rbindlist
motif_results <- data.table::rbindlist(motif_results_list)

# Clean up column names in the final, combined data frame
motif_results <- motif_results %>%
  janitor::clean_names()

# View the result
head(motif_results)

# Prepare data for plotting with manual order 
motif_plot_data <- motif_results %>%
  mutate(
    neglogP = -log_p_value,
    motif_name_clean = toupper(motif_name %>%
    stringr::str_extract("^[^/]+")),
    group_name = factor(group_name, levels = group_order_plots)
  ) %>%
  filter(neglogP > 50,                             # keep only good hits
         !is.na(group_name)) %>%                   # keep only wanted groups
  group_by(group_name) %>%
  
  arrange(desc(neglogP), .by_group = TRUE) %>%          # Sort largets first
 
   # ── Retain only top bZIP by p value
   {
     best_bzip   <- filter(., str_detect(motif_name_clean, regex("bZIP", ignore_case = TRUE))) %>%
                    slice_head(n = 3)
     non_bzip    <- filter(., !str_detect(motif_name_clean, regex("bZIP", ignore_case = TRUE)))
     bind_rows(best_bzip, non_bzip)
   } %>%
   
  slice_max(order_by = neglogP, n = 10, with_ties = FALSE) %>%   # top‑n after pruning
  ungroup() %>%
  mutate(motif_y = tidytext::reorder_within(motif_name_clean, neglogP, group_name))

# Flag bZIP motifs
motif_plot_data <- motif_plot_data %>%
  mutate(
    is_bzip = if_else(str_detect(motif_name_clean, regex("bZIP", ignore_case = TRUE)),
                      "bZIP", "Other")
  )

motif_bar_plot <- ggplot(motif_plot_data,
                         aes(x = neglogP, y = motif_y,
                             fill = is_bzip)) +
  geom_col(width = 0.7, color = "black", linewidth = 0.25) +
  tidytext::scale_y_reordered() +
  facet_wrap(~ group_name, scales = "free_y", ncol = 2) +
  scale_fill_manual(values = c("bZIP" = "#4B0082",    # dark purple
                               "Other" = "grey80")) +
  scale_x_continuous(expand = c(0, 0.05)) +
  labs(x = expression(-log[10](P) ~ "enrichment"), y = NULL, fill = NULL) +
  theme_bw(base_size = 10) +
  theme(
    strip.text       = element_text(face = "bold", size = 10),
    strip.background = element_blank(),
    axis.text.y      = element_text(color = "black", size = 8, face = "bold"),
    axis.text.x      = element_text(color = "black", size = 8),
    plot.title       = element_text(hjust = 0.5, face = "bold", size = 12),
    panel.spacing    = unit(1, "lines"),
    panel.grid       = element_blank(),
    panel.border     = element_blank(),
    axis.line        = element_line(color = "black", linewidth = 0.3)
  )

print(motif_bar_plot)



# Save 
ggsave(file.path("/Users/rileymullins/Documents/CC_Figs_08092025/synTF_Fig6", "homer_top_motifs_plot_filtered_to_top3_bzip.png"),
       motif_bar_plot, width = 8, height = 10, dpi = 300, bg = "white")
ggsave(file.path("/Users/rileymullins/Documents/CC_Figs_08092025/synTF_Fig6", "homer_top_motifs_plot_filtered_to_top3_bzip.pdf"),
       motif_bar_plot, width = 8, height = 10, bg = "white")



# Heatmap of JUN FOS BATF peaks
jfb_peaks <- all_sig %>% filter(group %in% c("JUN.FOS.BATF", "JUN","FOSL1","BATF")) %>% pull(peak_id)

# Read all files into a list and combine
combined_norm_matrix   <- fread("~/Documents/20250602_5BC_Exp9_V5_results/full_dataset_without_pool2/STEP_4_output_deseq2_peak_analysis/normalized_peak_matrices/combined_long_format_normalized_peak_matrix.csv",
                                nThread = 10)
# Filter to 
combined_norm_matrix_filter <- combined_norm_matrix %>% 
  filter(source_group  %in% c("JUN.FOS.BATF", "JUN","FOSL1","BATF")) %>%
  filter(group %in% c("JUN.FOS.BATF", "JUN","FOSL1","BATF","HyPBase")) %>% 
  filter(peak_id %in% jfb_peaks) %>%
  mutate(log_count = log2(normalized_count + 1)) %>%
  dplyr::select(peak_id, group, log_count)


head(combined_norm_matrix_filter)

# ------------------------------
# 1. Convert to GRanges
# ------------------------------
df_gr <- combined_norm_matrix_filter %>%
  separate(peak_id, into = c("chr", "start", "end"), sep = "[:\\-]", convert = TRUE) %>%
  mutate(
    start = as.numeric(start),
    end = as.numeric(end),
    group = as.character(group),
    log_count = as.numeric(log_count)
  )

gr <- GRanges(
  seqnames = df_gr$chr,
  ranges = IRanges(start = df_gr$start, end = df_gr$end),
  group = df_gr$group,
  log_count = df_gr$log_count
)

# ------------------------------
# 2. Merge overlapping peaks
# ------------------------------
gr_merged <- reduce(gr, ignore.strand = TRUE)

# Map original peaks to merged peaks
hits <- findOverlaps(gr, gr_merged)
df_map <- data.frame(
  original_peak = paste0(seqnames(gr)[queryHits(hits)], ":",
                         start(gr)[queryHits(hits)], "-",
                         end(gr)[queryHits(hits)]),
  merged_peak = paste0(seqnames(gr_merged)[subjectHits(hits)], ":",
                       start(gr_merged)[subjectHits(hits)], "-",
                       end(gr_merged)[subjectHits(hits)]),
  group = mcols(gr)$group[queryHits(hits)],
  log_count = mcols(gr)$log_count[queryHits(hits)]
)

# Aggregate log_count per merged_peak and group
merged_counts <- df_map %>%
  group_by(merged_peak, group) %>%
  summarise(log_count = sum(log_count), .groups = "drop")

# ------------------------------
# 3. Create matrix for heatmap
# ------------------------------
heatmap_mat <- merged_counts %>%
  pivot_wider(names_from = merged_peak, values_from = log_count, values_fill = 0) %>%
  column_to_rownames(var = "group") %>%
  as.matrix()

# Optional: reorder rows
row_order <- c("JUN", "FOSL1", "BATF", "JUN.FOS.BATF","HyPBase")
heatmap_mat <- heatmap_mat[row_order, , drop = FALSE]

# ------------------------------
# 4. Z-score columns
# ------------------------------
heatmap_mat_z <- apply(heatmap_mat, 2, function(x) {
  if(sd(x) == 0) rep(0, length(x)) else (x - mean(x)) / sd(x)
})

  
# ------------------------------
# 5. Custom column split
# ------------------------------

  
# --- 1. Define groups to use for splitting (exclude HyPBase) ---
split_groups <- setdiff(rownames(heatmap_mat_z), "HyPBase")

# --- 2. Precompute all possible non-redundant combos of split_groups ---
combo_levels <- unlist(lapply(1:length(split_groups), function(k) {
  combn(split_groups, k, FUN = function(x) paste(sort(x), collapse = "+"))
}))
combo_levels <- c(combo_levels, "None")  # add "None" for columns with no positives

# --- 3. Function to get the active combo for each column ---
get_group_combo <- function(values, groups) {
  active <- groups[values[groups] > 0]   # groups with Z > 0
  if (length(active) == 0) {
    return("None")
  } else {
    return(paste(sort(active), collapse = "+"))
  }
}

# --- 4. Assign each column to its combination ---
col_combos <- apply(heatmap_mat_z, 2, get_group_combo, groups = split_groups)
col_combos <- factor(col_combos, levels = combo_levels)

# --- 5. Heatmap ---
col_fun <- paletteContinuous("solarExtra")

# --- 1. Compute combination size for each column ---
combo_size <- sapply(as.character(col_combos), function(x) {
  if (x == "None") return(0)
  else return(length(strsplit(x, "\\+")[[1]]))
})


# --- 2. Define discrete colors for combo size (1–4) ---
combo_levels <- 1:4
combo_colors <- viridis(length(combo_levels), option = "turbo")
names(combo_colors) <- as.character(combo_levels)

# Optional: map 0 (None) to grey

# --- 3. Top annotation ---
top_anno <- HeatmapAnnotation(
  `Combo Size` = factor(combo_size, levels = names(combo_colors)),
  col = list(`Combo Size` = combo_colors),
    simple_anno_size = unit(3, "mm"),
  show_annotation_name = TRUE,
  annotation_name_side = "left",
    annotation_name_gp = gpar(fontsize = 10,fontface="plain")

)

# --- 3. Heatmap ---
ht <- Heatmap(
  heatmap_mat_z,
  name = "Z-score",
  col = paletteContinuous("solarExtra"),
  border = TRUE,
  use_raster = TRUE,
  raster_quality = 10,
  
  column_split = col_combos,
  cluster_columns = FALSE,
  cluster_rows = FALSE,
  show_column_names = FALSE,
  row_names_side = "left",
  row_names_gp = gpar(fontsize = 8, fontface = "bold"),
  
  top_annotation = top_anno,          # add top annotation
  column_title_gp = gpar(fontsize = 8),
  column_title = NULL,
  heatmap_legend_param = list(
    title = "Log2 Counts\n(Z-score)",
    title_position = "topleft",
    legend.position = "bottom",
    legend_height = unit(2, "cm")
  )
)

  

png(file.path(output_dir, "JUN_FOS_BATF_Peaks_Heatmap.png"),
      width = 10, height = 2, units = "in", res = 300)
  ComplexHeatmap::draw(ht ,
       heatmap_legend_side = "right",
       annotation_legend_side = "right",
       ht_gap                 = unit(0.05, "mm"),
       legend_gap             = unit(0.5, "mm"),
       merge_legend = TRUE)
  dev.off()
  
  pdf(file.path(output_dir,"JUN_FOS_BATF_Peaks_Heatmap.pdf"),
      width = 10, height = 2) 
  ComplexHeatmap::draw(ht ,
       heatmap_legend_side = "right",
       annotation_legend_side = "right",
       ht_gap                 = unit(0.05, "mm"),
       legend_gap             = unit(0.5, "mm"),
       merge_legend = TRUE)
  dev.off()
  
  
  
  
#------------------------------------------------------
# Only JUN.FOS.BATF containing combos
#------------------------------------------------------
#  Filter column splits 
col_combos_filtered <- col_combos[
  sapply(as.character(col_combos), function(x) {
    # keep if size == 1 or includes JUN.FOS.BATF
    (length(strsplit(x, "\\+")[[1]]) == 1) | grepl("JUN.FOS.BATF", x)
  })
]

head(col_combos_filtered)
# Also subset the heatmap matrix accordingly
heatmap_mat_z_filtered <- heatmap_mat_z[, names(col_combos_filtered), drop = FALSE]

# Update combo size for top annotation
combo_size_filtered <- sapply(as.character(col_combos_filtered), function(x) {
  if (x == "None") return(0)
  length(strsplit(x, "\\+")[[1]])
})

# Update top annotation
top_anno_filtered <- HeatmapAnnotation(
  `Combo Size` = factor(combo_size_filtered, levels = names(combo_colors)),
  col = list(`Combo Size` = combo_colors),
  simple_anno_size = unit(3, "mm"),
  show_annotation_name = TRUE,
  annotation_name_side = "left",
  annotation_name_gp = gpar(fontsize = 10, fontface="plain")
)

# --- Heatmap ---
ht_filtered <- Heatmap(
  heatmap_mat_z_filtered,
  name = "Z-score",
  col = paletteContinuous("solarExtra"),
  border = TRUE,
  use_raster = TRUE,
  raster_quality = 10,
  column_split = col_combos_filtered,
  cluster_columns = FALSE,
  cluster_rows = FALSE,
  show_column_names = FALSE,
  row_names_side = "left",
  row_names_gp = gpar(fontsize = 8, fontface = "bold"),
  top_annotation = top_anno_filtered,
  column_title_gp = gpar(fontsize = 8),
  column_title = NULL,
  heatmap_legend_param = list(
    title = "Log2 Counts\n(Z-score)",
    title_position = "topleft",
    legend.position = "bottom",
    legend_height = unit(2, "cm")
  )
)

# Draw the heatmap

png(file.path(output_dir, "only_JUN.FOS.BATF_combos_JUN_FOS_BATF_Peaks_Heatmap.png"),
      width = 10, height = 2, units = "in", res = 300)
  ComplexHeatmap::draw(ht_filtered ,
       heatmap_legend_side = "right",
       annotation_legend_side = "right",
       ht_gap                 = unit(0.05, "mm"),
       legend_gap             = unit(0.5, "mm"),
       merge_legend = TRUE)
  dev.off()
  
  pdf(file.path(output_dir,"only_JUN.FOS.BATF_combos_JUN_FOS_BATF_Peaks_Heatmap.pdf"),
      width = 10, height = 2) 
  ComplexHeatmap::draw(ht_filtered ,
       heatmap_legend_side = "right",
       annotation_legend_side = "right",
       ht_gap                 = unit(0.05, "mm"),
       legend_gap             = unit(0.5, "mm"),
       merge_legend = TRUE)
  dev.off()
  
  
  

# Bar plot of peaks per combo
# Compute combination size per column split
columns_per_split <- tibble(
  column_combo = factor(names(table(col_combos)), levels = levels(col_combos)),
  n_columns = as.numeric(table(col_combos))
) %>%
  filter(column_combo != "None")  # optional: exclude 'None' if present

# Map each column_combo to its combo size (number of TFs in the combination)
columns_per_split <- columns_per_split %>%
  mutate(combo_size = sapply(as.character(column_combo), function(x) {
    length(strsplit(x, "\\+")[[1]])
  }))

# --- Define discrete colors (same as heatmap top annotation) ---
combo_levels <- 1:4
combo_colors <- viridis(length(combo_levels), option = "turbo")
names(combo_colors) <- as.character(combo_levels)

# Plot
p <- ggplot(columns_per_split, aes(x = column_combo, y = n_columns, fill = factor(combo_size))) +
  geom_bar(stat = "identity", color = "black", linewidth = 0.25,width = 0.5) +
  scale_fill_manual(values = combo_colors, name = "Combo Size") +
  theme_minimal() +
    labs(x = "TF Combination", y = "Peaks")+
  theme_minimal(base_size = 10) +
  theme(
    text = element_text(color = "black"),
    plot.title = element_text(hjust = 0.5, face = "bold"),
    axis.title.y = element_text(face = "bold",color="black"),
    axis.title.x = element_text(face = "bold",color="black"),

    axis.text = element_text(face = "bold", color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
    
   # axis.text.x = element_blank(),

    axis.line = element_line(color = "black", size = 0.5),
    axis.ticks = element_line(color = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.background = element_blank(),
    legend.title = element_text(face = "bold", color = "black", size="8"),
    plot.background = element_blank(),
      legend.margin = margin(0, 0, 0, 0),
  legend.key.height = unit(0.25, "cm"),
  legend.spacing.x = unit(0.25, "cm"),
  legend.key.width = unit(0.25, "cm"),
    legend.position = "right"
  )+scale_y_continuous(expand = c(0, 0), limits = c(0,4000))

p
ggsave(file = file.path(output_dir,"total_peaks_per_combination.png"), plot = p, width = 6, height = 4, bg="white",dpi = 300)

# Save as .pdf
ggsave(file = file.path(output_dir,"total_peaks_per_combination.pdf"), plot = p, width = 6, height =4)



#------------------------------------------------------
# Only JUN.FOS.BATF combos
#------------------------------------------------------
# Compute combination size per column split
columns_per_split <- tibble(
  column_combo = factor(names(table(col_combos_filtered)), levels = levels(col_combos_filtered)),
  n_columns = as.numeric(table(col_combos_filtered))
) %>%
  filter(column_combo != "None")  %>%
  filter(n_columns != 0)

# Map each column_combo to its combo size (number of TFs in the combination)
columns_per_split <- columns_per_split %>%
  mutate(combo_size = sapply(as.character(column_combo), function(x) {
    length(strsplit(x, "\\+")[[1]])
  }))

# --- Define discrete colors (same as heatmap top annotation) ---
combo_levels <- 1:4
combo_colors <- viridis(length(combo_levels), option = "turbo")
names(combo_colors) <- as.character(combo_levels)

# Plot
p <- ggplot(columns_per_split, aes(x = column_combo, y = n_columns, fill = factor(combo_size))) +
  geom_bar(stat = "identity", color = "black", linewidth = 0.25,width = 0.5) +
  scale_fill_manual(values = combo_colors, name = "Combo Size") +
  theme_minimal() +
    labs(x = "TF Combination", y = "Peaks")+
  theme_minimal(base_size = 12) +
  theme(
    text = element_text(color = "black"),
    plot.title = element_text(hjust = 0.5, face = "bold"),
    axis.title.y = element_text(face = "bold",color="black"),
    axis.title.x = element_text(face = "bold",color="black"),

    axis.text = element_text(face = "bold", color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
    
   # axis.text.x = element_blank(),

    axis.line = element_line(color = "black", size = 0.5),
    axis.ticks = element_line(color = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.background = element_blank(),
    legend.title = element_text(face = "bold", color = "black", size="8"),
    plot.background = element_blank(),
      legend.margin = margin(0, 0, 0, 0),
  legend.key.height = unit(0.25, "cm"),
  legend.spacing.x = unit(0.25, "cm"),
  legend.key.width = unit(0.25, "cm"),
    legend.position = "right"
  )+scale_y_continuous(expand = c(0, 0), limits = c(0,4000))

p
ggsave(file = file.path(output_dir,"JUN.FOS.BATF_combos_only_total_peaks_per_combination.png"), plot = p, width = 6, height = 4, bg="white",dpi = 300)

# Save as .pdf
ggsave(file = file.path(output_dir,"JUN.FOS.BATF_combos_only_total_peaks_per_combination.pdf"), plot = p, width = 6, height =4)




# Export combo binding as bed format for motifs 
# Make sure it's character, not factor
peak_assignments <- as.character(col_combos_filtered)

# Extract peak coordinates (names of the vector)
peak_coords <- names(col_combos_filtered)

# Split coordinates into BED format (chr, start, end)
bed_df <- data.frame(
  peak = peak_coords,
  combo = peak_assignments,
  stringsAsFactors = FALSE
) %>%
  tidyr::separate(peak, into = c("chr", "pos"), sep = ":", remove = FALSE) %>%
  tidyr::separate(pos, into = c("start", "end"), sep = "-", remove = TRUE) %>%
  dplyr::mutate(
    start = as.integer(start),
    end   = as.integer(end)
  )
output_dir
# Export one BED file per unique TF combination
outdir <-file.path(output_dir,"HOMER_JUN_FOS_BATF_COMBO_BINDING")
dir.create(outdir, showWarnings = FALSE)

for (combo in unique(bed_df$combo)) {
  subset_bed <- bed_df %>%
    dplyr::filter(combo == !!combo) %>%
    dplyr::select(chr, start, end)
  
  # Build filename (sanitize '+' and '.' for safety)
  fname <- gsub("[+]", "_plus_", combo)
  fname <- gsub("[.]", "_", fname)
  outfile <- file.path(outdir, paste0(fname, "_significant_peaks.bed"))
  
  write.table(
    subset_bed,
    file = outfile,
    sep = "\t",
    quote = FALSE,
    row.names = FALSE,
    col.names = FALSE
  )
  
  message("Exported: ", outfile, " (", nrow(subset_bed), " peaks)")
}

#bash /Users/rileymullins/Documents/CC_Figs_08092025/synTF_Fig6/HOMER_JUN_FOS_BATF_COMBO_BINDING/run_homer_motifs.sh /Users/rileymullins/Documents/CC_Figs_08092025/synTF_Fig6/HOMER_JUN_FOS_BATF_COMBO_BINDING hg38 11

# Find top shared peak sets
all_sig_annots <- all_sig

# --- Convert to GRanges ---
make_gr <- function(df) {
  GRanges(
    seqnames = df$chr,
    ranges = IRanges(start = df$start, end = df$end),
    group = df$group,
    peak_id = df$peak_id
  )
}

gr_all <- make_gr(all_sig_annots)
groups <- unique(mcols(gr_all)$group)

# --- Generate all combinations of 3+ groups only ---
all_combos <- unlist(
  lapply(2:length(groups), function(k) combn(groups, k, simplify = FALSE)),
  recursive = FALSE
)

# --- Count overlaps for a given combo ---
count_overlaps_for_combo <- function(combo) {
  gr_list <- lapply(combo, function(g) gr_all[mcols(gr_all)$group == g])

  # Start with first group
  overlap_gr <- gr_list[[1]]

  # Sequentially intersect with the rest (skip the first since it's already in overlap_gr)
  for(i in 2:length(gr_list)) {
    hits <- findOverlaps(overlap_gr, gr_list[[i]])
    overlap_gr <- overlap_gr[queryHits(hits)]
    if (length(overlap_gr) == 0) break  # early exit if no overlaps remain
  }

  tibble(
    groups = paste(combo, collapse = "_x_"),
    n_overlaps = length(unique(mcols(overlap_gr)$peak_id)),
    overlapping_peak_ids = list(unique(mcols(overlap_gr)$peak_id)),
    tf_list = list(combo)  # store which TFs are involved
  )
}

# --- Apply to all combos ---
overlap_results <- map_dfr(all_combos, count_overlaps_for_combo)

# --- For each TF, get top N interactions ---
top_interactions_per_tf <- overlap_results %>%
  unnest(tf_list) %>%         
  group_by(tf_list) %>%
  slice_max(n_overlaps, n = 999999, with_ties = FALSE) %>% 
  ungroup() %>%
  arrange(tf_list, desc(n_overlaps)) %>%
  rename(tf = tf_list)

# --- View results ---
top_interactions_per_tf
head(top_interactions_per_tf)





##############################################################################################################################
# Find co-bound sites with differential gene expression
##############################################################################################################################
library(dplyr)
library(tidyr)
library(GenomicRanges)
library(data.table)
library(TxDb.Hsapiens.UCSC.hg38.knownGene)
library(org.Hs.eg.db)

python_output_dir <- "/Users/rileymullins/Documents/20250602_5BC_Exp9_V5_results/full_dataset_without_pool2"

# Load data
annot <- fread(file.path(python_output_dir,
  "STEP_4_output_deseq2_peak_analysis/HOMER_annotations_COMBINED_all_Group_vs_Control_results.csv"))

dt <- fread("/Users/rileymullins/Documents/engreitz_cd8_t_cell_encode_re2g_links/distinct_gene_pairs_unmerged_final.csv") %>%
  distinct(enh_coord, chr, start, end, gene_name)

se_rna <- readRDS(file.path(python_output_dir, "RNA_dds.rds"))
rna_mat <- assay(se_rna)

# Setup TF groups
tf_groups <- c("BATF","JUN","JUN.FOS.BATF")
ref_tf    <- "JUN.FOS.BATF"

annot <- annot %>% mutate(group = toupper(group))
tf_groups <- toupper(tf_groups)
ref_tf <- toupper(ref_tf)

# Build GRanges per TF
make_gr <- function(df) {
  df %>%
    separate(peak_id, into = c("chr","start","end"), sep = "[:-]", convert = TRUE, fill = "right") %>%
    filter(!is.na(chr) & !is.na(start) & !is.na(end)) %>%
    makeGRangesFromDataFrame(keep.extra.columns = TRUE)
}

gr_list <- lapply(tf_groups, function(tf) make_gr(annot %>% filter(group == tf)))
names(gr_list) <- tf_groups

# Keep JFB peaks that overlap JUN or BATF
jfb_gr   <- gr_list[[ref_tf]]
jun_gr   <- gr_list[["JUN"]]
batf_gr  <- gr_list[["BATF"]]

hits_jun  <- findOverlaps(jfb_gr, jun_gr)
hits_batf <- findOverlaps(jfb_gr, batf_gr)

jfb_overlap <- jfb_gr[unique(c(queryHits(hits_jun), queryHits(hits_batf)))]

cat("Final JFB peaks after JUN/BATF overlap:", length(jfb_overlap), "\n")
names(jfb_overlap) <- paste0(seqnames(jfb_overlap), ":", start(jfb_overlap), "-", end(jfb_overlap))

#  Map to enhancer–gene links
enhancer_db_gr <- makeGRangesFromDataFrame(dt,
  seqnames.field = "chr", start.field = "start", end.field = "end",
  keep.extra.columns = TRUE)

enh_hits <- findOverlaps(jfb_overlap, enhancer_db_gr)
enhancer_pairs <- data.frame(
  acr_id = names(jfb_overlap[queryHits(enh_hits)]),
  gene   = mcols(enhancer_db_gr)$gene_name[subjectHits(enh_hits)],
  is_enhancer = TRUE, is_promoter = FALSE
)

# Map to promoter–gene links
txdb <- TxDb.Hsapiens.UCSC.hg38.knownGene
genes_gr <- genes(txdb)
gene_map <- AnnotationDbi::select(org.Hs.eg.db,
  keys = genes_gr$gene_id, columns = "SYMBOL", keytype = "ENTREZID")
mcols(genes_gr)$gene_symbol <- gene_map$SYMBOL[match(genes_gr$gene_id, gene_map$ENTREZID)]
genes_gr <- genes_gr[!is.na(mcols(genes_gr)$gene_symbol) &
                     mcols(genes_gr)$gene_symbol %in% rownames(rna_mat)]

promoter_windows <- promoters(genes_gr, upstream = 500, downstream = 500)
prom_hits <- findOverlaps(jfb_overlap, promoter_windows)

promoter_pairs <- data.frame(
  acr_id = names(jfb_overlap[queryHits(prom_hits)]),
  gene   = mcols(promoter_windows)$gene_symbol[subjectHits(prom_hits)],
  is_promoter = TRUE, is_enhancer = FALSE
)

#  Combine enhancer + promoter pairs
all_pairs <- bind_rows(promoter_pairs, enhancer_pairs) %>%
  group_by(acr_id, gene) %>%
  summarise(
    is_promoter = any(is_promoter),
    is_enhancer = any(is_enhancer),
    .groups="drop"
  ) %>%
  mutate(
    annotation = case_when(
      is_promoter & is_enhancer  ~ "Promoter_Enhancer",
      is_promoter & !is_enhancer ~ "Promoter",
      !is_promoter & is_enhancer ~ "Enhancer",
      TRUE                       ~ "Other"
    )
  )

# Add TF binding indicators
tf_binding_info <- tibble(acr_id = names(jfb_overlap))
for (tf in tf_groups) {
  tf_hits <- findOverlaps(jfb_overlap, gr_list[[tf]])
  bound_acrs <- names(jfb_overlap[unique(queryHits(tf_hits))])
  tf_binding_info[[tf]] <- as.integer(tf_binding_info$acr_id %in% bound_acrs)
}

all_model_results_final <- all_pairs %>%
  left_join(tf_binding_info, by="acr_id") %>%
  filter(JUN.FOS.BATF == 1 & (JUN == 1 | BATF == 1))


# Final summary
cat("\nFinal number of gene–peak pairs:", nrow(all_model_results_final), "\n")
cat("Unique genes:", length(unique(all_model_results_final$gene)), "\n")
cat("Annotation breakdown:\n")
print(table(all_model_results_final$annotation))

head(all_model_results_final)


##############################################################################################################################
# Plot RNA at genes bound at same site (promtoer or enhancer)
##############################################################################################################################

# Mapping of tf to atac/rna name
group_to_tf_map <- c(
  "JUN.FOS.BATF"     = "cJUN_cFOS_BATF",
  "BATF"             = "BATF",
  "MAFF.ATF3.BATF2"  = "MAFF_ATF3_BATF2",
  "BATF3.BATF2.MAFF" = "BATF3_BATF2_MAFF",
  "BATF3.JDP2.BATF2" = "BATF3_JDP2_BATF2",
  "FOSL1.BATF.MAFA"  = "FOSL1_BATF_MAFA",
  "JUN"              = "JunB",
  "FOSL1"            = "FOSL1",
  "CAR_GFP"          = "CAR_GFP"
)



# Call DEGs to use in fitering
python_output_dir          <- "/Users/rileymullins/Documents/20250602_5BC_Exp9_V5_results/full_dataset_without_pool2"
rna_path          <- file.path(python_output_dir,"RNA_dds.rds")
binding_data_path <- file.path(output_dir, "HOMER_annotations_COMBINED_all_Group_vs_Control_results.csv")

rna            <- readRDS(rna_path)
all_sig_annots <- fread(all_sig_file)



# Prepare RNA matrix
vsd                  <- DESeq2::vst(rna, blind = FALSE)
vst_mat              <- assay(vsd)
tf_conditions_in_rna <- intersect(unique(as.character(vsd$TF)), unname(group_to_tf_map))

mean_expr_list <- lapply(tf_conditions_in_rna, function(tf) {
  cols_for_tf <- vsd$TF == tf
  rowMeans(vst_mat[, cols_for_tf, drop = FALSE], na.rm = TRUE)
})
mean_expr_mat <- do.call(cbind, mean_expr_list)
colnames(mean_expr_mat) <- tf_conditions_in_rna

# Rename and set conditions
dds_rna_res        <- rna
all_rna_genes      <- rownames(dds_rna_res)

control_group      <- "CAR_GFP"
conditions_to_test <- setdiff(unique(dds_rna_res$TF), control_group)

# Extract RNA Results
rna_results_list <- lapply(conditions_to_test, function(cond) {
  res <- results(dds_rna_res, contrast = c("TF", cond, control_group))
  list(l2fc = setNames(res$log2FoldChange, rownames(res)), padj = setNames(res$padj, rownames(res)))
})
names(rna_results_list)   <- conditions_to_test
log2fc_rna                <- do.call(cbind, lapply(rna_results_list, `[[`, "l2fc"))
colnames(log2fc_rna)      <- paste0(conditions_to_test, "_vs_", control_group)
padj_rna                  <- do.call(cbind, lapply(rna_results_list, `[[`, "padj"))
colnames(padj_rna)        <- paste0(conditions_to_test, "_vs_", control_group)

# Make dfs of the results
# RNA sig deg df
FDR_cutoff <- 0.05
logfc_cutoff <- 0.75

rna_sig_df <- map_dfr(conditions_to_test, ~{
  results(dds_rna_res, contrast = c("TF", .x, control_group)) %>%
    as.data.frame() %>%
    rownames_to_column("gene") %>%
    filter(!is.na(padj), padj <= FDR_cutoff, abs(log2FoldChange) >= logfc_cutoff) %>%
    select(gene, log2fc = log2FoldChange, padj) %>%
    mutate(comparison_v_cargfp = .x,
           type = "RNA")
})


# Define TFs
tfs <- c("JUN", "BATF", "JUN.FOS.BATF")

# Generate all non-empty combinations of TFs
tf_combos <- unlist(lapply(1:length(tfs),
                           function(k) combn(tfs, k, simplify = FALSE)),
                    recursive = FALSE)

# Extract gene sets for each combo (intersection = require all to be 1)
gene_sets <- map(tf_combos, function(tf_subset) {
  res <- all_model_results_final %>%
    filter(if_all(all_of(tf_subset), ~ .x == 1)) %>%
   # filter(str_detect(annotation, regex("promoter", ignore_case = TRUE))) %>% # FIlter to only promoter
    pull(gene) %>%
    unique()
  
  tibble(
    combo = paste(tf_subset, collapse = "_"),
    genes = list(res)
  )
})

# Bind into a single tibble
gene_sets_df <- bind_rows(gene_sets)

# Map binding names to RNA/ATAC names (if mapping exists for each)
gene_sets_df <- gene_sets_df %>%
  mutate(combo_mapped = map_chr(strsplit(combo, "_"), function(x) {
    paste(unname(group_to_tf_map[x]), collapse = "_")
  }))



# Function to plot log2fc
plot_log2fc_heatmap <- function(mat, out_prefix, plot_title, 
                                interesting_genes, row_km = 4, 
                                color_function) {
  # --- Prepare matrix ---
  mat_for_clustering <- as.matrix(mat)
  mat_for_clustering[is.na(mat_for_clustering)] <- 0
  mat_for_clustering <- pmax(pmin(mat_for_clustering, 1), -1)

  # --- Perform clustering ---
  set.seed(123)
  row_km_ctrs <- min(row_km, nrow(mat_for_clustering))
  km_row_assign <- kmeans(mat_for_clustering, centers = row_km_ctrs,
                          nstart = 25, iter.max = 50)$cluster

  # --- Optional: order row clusters by "JUN.FOS.BATF" mean ---
  cluster_means <- tapply(mat_for_clustering[, "JUN.FOS.BATF"], km_row_assign, mean)
  cluster_order <- order(cluster_means, decreasing = TRUE)
  km_row_assign <- factor(km_row_assign, levels = cluster_order)

  # --- Reorder rows by cluster assignment ---
  order_idx <- order(km_row_assign)
  mat_ordered <- mat_for_clustering[order_idx, , drop = FALSE]
  km_split_vector <- km_row_assign[order_idx]

  # --- Only label interesting_genes present in this matrix ---
  interesting_genes_present <- intersect(interesting_genes, rownames(mat_ordered))
  if (length(interesting_genes_present) > 0) {
    idx <- match(interesting_genes_present, rownames(mat_ordered))
    ha <- rowAnnotation(
      mark = anno_mark(
        at = idx,
        labels = interesting_genes_present,
        labels_gp = gpar(fontsize = 7),
        padding = unit(2, "mm")
      ),
      annotation_name_side = "top"
    )
  } else {
    ha <- NULL
  }

  # --- Build the heatmap ---
  ht <- Heatmap(
    mat_ordered,
    name                  = plot_title,
    col                   = color_function,
    row_split             = km_split_vector,
    column_split          = colnames(mat_ordered), # <-- ADDED THIS LINE
    cluster_rows          = TRUE,
    cluster_row_slices    = FALSE,
    cluster_columns       = FALSE,
    right_annotation      = ha,
    show_row_dend         = FALSE,
    show_row_names        = FALSE,
    row_gap               = unit(0.75, "mm"),
    column_gap            = unit(0.75, "mm"),
    border                = "black",
    row_title             = NULL,
    column_title          = NULL,
    column_names_gp       = gpar(fontsize = 8, fontface = "bold"),
    heatmap_legend_param  = list(
      title     = "Log2FC",
      title_gp  = gpar(fontsize = 7, fontface = "bold"),
      labels_gp = gpar(fontsize = 7),
      at        = c(-1, 0, 1),
      labels    = c("≤-1", "0", "≥1")
    )
  )

  # --- Save plots ---
  png(paste0(out_prefix, ".png"), width = 2.75, height = 5, units = "in", res = 300)
  ComplexHeatmap::draw(ht)
  dev.off()

  pdf(paste0(out_prefix, ".pdf"), width = 2.75, height = 5)
  ComplexHeatmap::draw(ht)
  dev.off()

  cat("Saved Log2FC heatmap to:", out_prefix, "\n")
  
  # --- Return debug info ---
  return(list(
    total_genes_plotted = nrow(mat_ordered),
    interesting_genes_requested = length(interesting_genes),
    interesting_genes_found = length(interesting_genes_present),
    interesting_genes_labeled = interesting_genes_present
  ))
}

# Define genes to label 
# CORRECTED interesting genes list - fixed TNFSRF1B -> TNFRSF1B
interesting_genes_list <- c(
  "GZMA", "GZMH", "GZMB", "GZMK", "PDCD1", "TIGIT", "TNFRSF9", "RUNX1", "RUNX3",
  "NFATC3", "NFIL3", "BCL2", "FAS", "PRDM1", "KLRD1", "KLRG1", "LEF1", "BACH2",
  "HAVCR2", "IL2RA", "IL12RB1", "IL12RB2", "ID2", "ID3", "NFKB1", "NFKBIZ",
  "BCL11B", "KLF7", "MYB", "FOXP1", "IL7R", "SOX4", "RUNX2", "IFNG", "TNF", "IKZF3",
  "IKZF2", "IKZF1", "CSF1", "FASLG", "PRF1", "BATF3", "IRF4", "IRF2", "KLRC1", "KLRC2","BATF3",
  "IRF1", "CD28", "CTLA4", "KLF6", "KLF2", "TOX", "TOX2", "TCF7", "ICOS", "LAG3", "TIGIT",
  "PDCD1", "TNFRSF9", "TNF", "FASLG", "BHLHE40", "ARID5B", "FYN", "GZMB",
  "IL2RA", "IL2RB", "IRF4", "NKG7", "TCF7", "FOSL1", "JUN", "BATF", "CCL5", "GZMA",
  "GZMH", "PRF1", "LAG3", "ZAP70", "KLRG1", "OAS1", "OAS2", "RUNX1", "RUNX2", "RUNX3",
  "SLAMF6", "TANK", "XCL2", "RBPJ", "NFATC3", "NFAT5", "FAS", "PRDM1", "BACH2", "ID2",
  "ID3", "NFKB1", "FOXP1", "IL7R", "SOX4", "RELA", "FOS", "IFNG", "IKZF2", "IRF2",
  "KLRC2", "KLRC1", "IRF1", "CD28", "CTLA4", "TOX", "TOX2", "ICOS", "TIGIT", "CD69",
  "LEF1", "CCR7", "FOXO1", "STAT5A", "STAT5B", "HIF1A", "IKZF3", "SNX9", "FUT8", "PIK3CD",
  "AHR", "LAYN", "PIK3C2B", "KAT6A",
  "BTLA","CBLB","GNLY","ICOS", "IL13", "IL23R", "IL26", "IL4", "IL5", "IL23R", "KLRD1",
  "LEF1","SATB1","SLAMF7","SOX4","TLR2","WNT7B","ZBTB32","CXCR4","IL2RA","CD69","PIK3CA","TNFRSF1B", 
  "BATF3","CD63","TGFB3","PDCD1LG2","CBLB","GNLY","FCGR3A","TNFRSF1A","TNFSF10",
  "PPP3CC","LEF1",
  "SRF","BIRC2","BCL2A1","FOXN3","CSF2","IFI16","DEK","CASP1","ITGA4","ITGA2","ZC3H12A"
)
# Remove duplicates and sort for easier inspection
interesting_genes_list <- unique(interesting_genes_list)
interesting_genes_list <- sort(interesting_genes_list)


# Define variables
all_model_results_final_degs <- list()

degs_df <- rna_sig_df # Use the full significant results data frame for filtering
control_name <- "CAR_GFP"
combo_to_filter <- c("JUN_JUN.FOS.BATF", "BATF_JUN.FOS.BATF", "JUN_BATF_JUN.FOS.BATF")
all_model_results_final_degs <- list()

for (combo in combo_to_filter) {
  message(sprintf("--- Processing combo: %s ---", combo))
  
  # 1. Get the full set of genes for this binding combination
  group_genes <- gene_sets_df %>% 
    filter(combo == !!combo) %>% 
    pull(genes) %>% 
    unlist() %>% 
    unique()
  
  cat(sprintf("Step 1: Found %d total genes with the '%s' binding signature.\n", length(group_genes), combo))

  # 2. Identify DEGs specific to THIS combo's conditions
  tf_names_in_combo <- strsplit(combo, "_")[[1]]
  rna_conditions_in_combo <- unname(group_to_tf_map[tf_names_in_combo])
  
  combo_specific_degs <- degs_df %>%
    filter(comparison_v_cargfp %in% rna_conditions_in_combo) %>%
    pull(gene) %>%
    unique()
  
  cat(sprintf("Step 2: Found %d unique DEGs across conditions specific to this combo (%s).\n", length(combo_specific_degs), paste(rna_conditions_in_combo, collapse=", ")))

  # 3. Filter the binding-defined genes to keep only the ones that are also DEGs
  final_genes_to_plot <- intersect(group_genes, combo_specific_degs)
  
  cat(sprintf("Step 3: After filtering, %d genes remain to be plotted.\n", length(final_genes_to_plot)))

  if (length(final_genes_to_plot) == 0) {
    message("No overlapping genes found for this combo after filtering. Skipping.\n")
    next
  }

  # 4. Prepare the matrix for plotting
  contrast_names <- paste0(rna_conditions_in_combo, "_vs_", control_name)
  available_contrasts <- intersect(contrast_names, colnames(log2fc_rna))
  log2fc_rna_plot <- log2fc_rna[final_genes_to_plot, available_contrasts, drop = FALSE]

  # Rename columns back to binding names for clarity
  colnames(log2fc_rna_plot) <- sapply(colnames(log2fc_rna_plot), function(x) {
    base <- sub("_vs_.*$", "", x)
    binding_name <- names(group_to_tf_map)[group_to_tf_map == base]
    if (length(binding_name) > 0) binding_name[1] else base
  })

  # 5. Call the corrected plotting function
  plot_log2fc_heatmap(
    mat = log2fc_rna_plot,
    out_prefix = file.path(output_dir, paste0("log2FC_RNA_", combo)),
    plot_title = paste0("RNA_", combo),
    interesting_genes = interesting_genes_list,
    color_function = color_fun_rna,
    row_km = min(4, nrow(log2fc_rna_plot))
  )
  
  # Store results
  all_model_results_final_degs[[combo]] <- all_model_results_final %>% 
    filter(gene %in% rownames(log2fc_rna_plot)) %>% 
    distinct(acr_id, gene)
    
  message(sprintf("Finished processing for %s. Plotted %d genes.\n", combo, nrow(log2fc_rna_plot)))
}

