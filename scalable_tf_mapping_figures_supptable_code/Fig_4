#==================================================================================================
# R SCRIPT FOR FIGURE 4 ANALYSIS (Updated file paths to be generalizable. Simplified code.) 
# DATE: October 03, 2025
#
# DESCRIPTION:
# This script processes the public single-cell RNA-seq atlas of CD8+ T cells to perform
# a detailed regulon and gene program analysis. The key steps include:
# 1.  Loading and filtering the scRNA-seq data to create a Seurat object.
# 2.  Generating metacells to create robust expression profiles.
# 3.  Calculating proportionality (rho) between TFs and target genes to define regulons using metacells.
# 4.  Calculating module scores for the identified regulons using metacells.
# 5.  Performing Non-Negative Matrix Factorization (NMF) to discover underlying gene programs using metacells.
# 6.  Visualizing results through heatmaps, dimension plots, and similarity matrices using metacells.
#==================================================================================================

# --- 1. LOAD LIBRARIES ---
suppressPackageStartupMessages({
  library(Seurat)
  library(hdWGCNA) 
  library(WGCNA)  
  library(tidyverse)
  library(UCell)
  library(GeneNMF)
  library(ComplexHeatmap)
  library(circlize)
  library(pheatmap)
  library(viridis)
  library(qs) 
})

# Allow WGCNA functions to use multiple threads for performance.
allowWGCNAThreads(nThreads = 12)

# --- 2. DEFINE FILE PATHS AND DIRECTORIES ---
base_dir <- "/path/to/your/project/directory" 

# Construct input and output directories from the base path.
python_output_dir <- file.path(base_dir, "Acute_v_Chronic_Data")
output_dir <- file.path(python_output_dir, "STEP_4_output_deseq2_peak_analysis_ACUTE_ONLY")
bulk_rna_dir <- file.path(output_dir, "wherry_bulk_rna_seq_analysis")
bulk_atac_dir <- file.path(output_dir, "wherry_bulk_atac_analysis")
bzip_results_outdir <- file.path(bulk_atac_dir, "bZIP_combined_linear_regression")
figdir <- file.path(base_dir, "CC_Figs_08092025/figs")
metadata_dir <- file.path(base_dir, "huARdb_CD8_Tcellatlas") # Centralized metadata path

# Create output directories if they do not already exist.
dir.create(bzip_results_outdir, recursive = TRUE, showWarnings = FALSE)
dir.create(figdir, recursive = TRUE, showWarnings = FALSE)

# --- 3. LOAD INITIAL DATA ---
# Load the results from the TF-gene pair modeling analysis.
all_model_results_final <- read.csv(file.path(figdir,"with_promoter_genes_added_back_ALL_ACUTE_AND_CHRONIC_FILTERED_final_annotated_results_from_acr_gene_pairs_for_modeling.csv"))

# --- 4. LOAD AND PREPARE huARdb METADATA ---
# Load the main metadata file.
metadata <- read.csv(file.path(metadata_dir, "huARdb_CD8_metadata.csv"))
rownames(metadata) <- metadata$X
metadata$X <- NULL
metadata$barcode <- rownames(metadata)

# Create a unique clone ID from TCR sequences.
metadata$clone_id <- paste0(
  metadata$IR_VDJ_1_v_call, "_", 
  metadata$IR_VDJ_1_j_call, "_", 
  metadata$IR_VDJ_1_junction_aa, "_", 
  metadata$IR_VJ_1_v_call, "_", 
  metadata$IR_VJ_1_j_call, "_", 
  metadata$IR_VJ_1_junction_aa
)

# Load and merge the metadata for exhausted T-cell (Tex) subclusters.
texmd <- read.csv(file.path(metadata_dir, "huardb_Tex_subcluster_metadata.csv"))
rownames(texmd) <- texmd$X
texmd$X <- NULL
texmd$barcode <- rownames(texmd)
metadata <- dplyr::left_join(metadata, texmd, by = intersect(colnames(metadata), colnames(texmd)))
rownames(metadata) <- metadata$barcode

# Filter metadata to select cells from specific tissues, diseases, and subsets.
tissues_of_interest <- c("PBMC", "TIL", "Lymph Node")
disease_type_of_interset <- c("Healthy", "Solid tumor")
subsets_to_keep <- setdiff(unique(metadata$cell_subset), c("ag_spcific")) # Exclude antigen-specific cells.

metadata <- metadata %>% 
  dplyr::filter(disease_type %in% disease_type_of_interset &
                meta_tissue_type %in% tissues_of_interest &
                cell_subset %in% subsets_to_keep)

# Consolidate cell subtype annotations.
metadata$cell_subtype_4 <- ifelse(is.na(metadata$cell_subtype_4), metadata$cell_subtype_3, metadata$cell_subtype_4)
metadata$Cluster_names <- metadata$cell_subtype_4

# --- 5. CREATE AND PROCESS SEURAT OBJECT ---
# Create a Seurat object from the 10X count data.
db <- CreateSeuratObject(
  counts = Read10X(file.path(bulk_rna_dir, "huARdb_CD8_T_cell_atlas_Healthy_SolidTumor_PBMC_TIL_ParatumorTissue_NormalTissue_LymphNode_min_ftr_per_cell_500_min_cells_per_gene_20_pct_mt_10"))
)

# Filter the object to keep only cells that passed the metadata filtering.
cells_to_keep <- intersect(metadata$barcode, colnames(db))
db <- subset(db, cells = cells_to_keep)

# Calculate mitochondrial gene percentage and add metadata.
db[["percent.mt"]] <- PercentageFeatureSet(object = db, pattern = "^MT-")
db <- AddMetaData(db, metadata = metadata)
db <- subset(db, subset = (percent.mt <= 7.5)) # Filter out cells with high mitochondrial content.

# Re-create the object to ensure a clean counts slot.
db <- CreateSeuratObject(
  counts = GetAssayData(db, assay="RNA", layer="counts"),
  assay = "RNA",
  meta.data = db@meta.data
)
DefaultAssay(db) <- "RNA"

# Add UMAP reductions for both Tex subclusters and the full dataset.
umaptex <- read.csv(file.path(metadata_dir, "huardb_Tex_subcluster_umap.csv"))
umaptex <- umaptex %>% filter(X %in% colnames(db))
rownames(umaptex) <- umaptex$X
umaptex$X <- NULL
db[["umaptex"]] <- CreateDimReducObject(embeddings = as.matrix(umaptex), key = "UMAPtex_")

umap <- read.csv(file.path(metadata_dir, "huARdb_CD8_umap.csv"))
umap <- umap %>% filter(X %in% colnames(db))
rownames(umap) <- umap$X
umap$X <- NULL
db[["umap"]] <- CreateDimReducObject(embeddings = as.matrix(umap), key = "UMAP_")

# Define a consistent factor order for all cell cluster annotations.
full_levels <- c(
  "Tn", "Early Tcm/Tem", "Tcm", "GZMK+ Tem", "GNLY+ Temra", "CMC1+ Temra", 
  "ZNF683+ Teff", "MAIT", "ILTCK", "MACF1+ T", "CREM+ Trm", "ITGB2+ Trm", 
  "ITGAE+ Trm", "Tpex", "GZMK+ Tex", "XBP1+ Tex", "ITGAE+ Tex", "S100A11+ Tex", 
  "GZMK+ Tex ISG+", "ITGAE+ Tex IL7R+", "ITGAE+ Tex ISG+", "GZMK+ Tex IL7R+", 
  "GZMK+ Tex TNFRSF9+", "ITGAE+ Tex DUSP1+", "GZMK+ Tex DUSP1+", "Cycling T"
)

# Apply the ordered levels to the different metadata columns.
db$cell_subtype_4 <- factor(db$cell_subtype_4, levels = intersect(full_levels, unique(db$cell_subtype_4)))
db$cell_subtype_3 <- factor(db$cell_subtype_3, levels = intersect(full_levels, unique(db$cell_subtype_3)))
db$Cluster_names <- factor(db$Cluster_names, levels = intersect(full_levels, unique(db$Cluster_names)))
Idents(db) <- db$Cluster_names # Set the primary identity.

# Optional: Save/Load the processed Seurat object to save time.
# qsave(db, file.path(figdir,"huARdb_Full_scRNA_mt7.5_full_and_tex_subclustering_umap_and_metadata.rds"))
# db <- qread(file.path(figdir,"huARdb_Full_scRNA_mt7.5_full_and_tex_subclustering_umap_and_metadata.rds"))

# --- 6. METACELL CREATION ---
# Prepare the Seurat object for metacell analysis using hdWGCNA's function.
db@misc[["active_wgcna"]] <- NULL 
db@misc[["metacell"]] <- NULL
gc() # Free up memory.
db <- SetupForWGCNA(db, wgcna_name = "metacell", features = "TOX") # 'features' is a required placeholder.

# Remove data layer to reduce memory footprint before metacell generation.
db@assays$RNA$data <- NULL
rm(metadata, texmd, umap, umaptex)
gc()

# Generate metacells by aggregating cells within each cluster.
db <- MetacellsByGroups(
  db,
  group.by = c("Cluster_names"),
  ident.group = "Cluster_names",
  k = 15, # Number of nearest neighbors for aggregation.
  reduction = "umap",
  assay = "RNA",
  slot = "counts",
  layer = "counts",
  mode = "sum", # Sum counts of single cells to create metacell counts.
  min_cells = 50, # Minimum group size to create metacells from.
  max_shared = 5,
  target_metacells = 1000000,
  max_iter = 5000,
  verbose = TRUE
)

# Extract the metacell object.
metacell <- db@misc[["metacell"]][["wgcna_metacell_obj"]]

# Optional: Save/Load the metacell object.
# qsave(metacell, file.path(figdir,"huARdb_filtered_metacell_object_hdWGCNA_Function_MetacellsByGroups_k15_mincells50_maxshared5_sum_counts_groupbyCluster_names.rds"))
# metacell <- qread(file.path(figdir,"huARdb_filtered_metacell_object_hdWGCNA_Function_MetacellsByGroups_k15_mincells50_maxshared5_sum_counts_groupbyCluster_names.rds"))
rm(db); gc() # Clean up memory.

# --- 7. PROCESS METACELL OBJECT ---
# Apply the ordered factor levels to the metacell object.
metacell$Cluster_names <- factor(metacell$Cluster_names, levels = intersect(full_levels, unique(metacell$Cluster_names)))
Idents(metacell) <- metacell$Cluster_names

# Create a broader cluster definition by collapsing Tex subclusters.
metacell$broad_clusters <- as.character(metacell$Cluster_names)
metacell$broad_clusters[grep("^GZMK.*Tex", metacell$broad_clusters)]  <- "GZMK+ Tex"
metacell$broad_clusters[grep("^XBP1.*Tex", metacell$broad_clusters)]  <- "XBP1+ Tex"
metacell$broad_clusters[grep("^ITGAE.*Tex", metacell$broad_clusters)] <- "ITGAE+ Tex"
metacell$broad_clusters <- factor(metacell$broad_clusters, levels = intersect(full_levels, unique(metacell$broad_clusters)))

# Create the broadest cluster definition: exhausted (exh) vs. non-exhausted (nonexh).
nonexh_clusters <- c("Tn", "Early Tcm/Tem", "Tcm", "GZMK+ Tem", 
                     "GNLY+ Temra", "CMC1+ Temra", "ZNF683+ Teff", 
                     "MAIT", "ILTCK", "MACF1+ T", "CREM+ Trm", 
                     "ITGB2+ Trm", "ITGAE+ Trm")
exh_clusters <- c("Tpex", "GZMK+ Tex", "XBP1+ Tex", "ITGAE+ Tex","Cycling T")

metacell$broadest_cluster <- ifelse(metacell$broad_clusters %in% nonexh_clusters, 
                                    "nonexh",
                                    ifelse(metacell$broad_clusters %in% exh_clusters,
                                           "exh", 
                                           NA))

# --- 8. PROPORTIONALITY-BASED REGULON ANALYSIS ---
# Prepare TF-gene pairs from the modeling results.
tf_cols <- grep("_Acute$|_Chronic$", colnames(all_model_results_final), value = TRUE)
tf_gene_lists <- list()
for (tf_column_name in tf_cols) {
  new_list_name <- sub("_Acute|_Chronic", "", tf_column_name)
  genes <- unique(all_model_results_final$gene[all_model_results_final[[tf_column_name]] == 1])
  genes <- genes[!grepl("^RPS|^RPL", genes)] # Exclude ribosomal genes.
  if (new_list_name %in% names(tf_gene_lists)) {
    tf_gene_lists[[new_list_name]] <- unique(c(tf_gene_lists[[new_list_name]], genes))
  } else {
    tf_gene_lists[[new_list_name]] <- genes
  }
}
tf_gene_pairs_for_modeling <- do.call(rbind, lapply(names(tf_gene_lists), function(tf) {
  data.frame(TF = tf, gene = tf_gene_lists[[tf]], stringsAsFactors = FALSE)
}))
tf_gene_pairs_for_modeling <- tf_gene_pairs_for_modeling %>%
  filter(TF %in% rownames(metacell) & gene %in% rownames(metacell)) %>% 
  distinct(TF, gene)

# Normalize metacell data using Centered Log-Ratio (CLR) for proportionality analysis.
metacell <- NormalizeData(metacell, normalization.method = "CLR")

# Define functions to calculate proportionality (rho) without p-values.
rho_p_single <- function(Ai, Aj) {
  var_sum <- var(Ai, na.rm = TRUE) + var(Aj, na.rm = TRUE)
  if (is.na(var_sum) || var_sum == 0) return(NA_real_)
  1 - (var(Ai - Aj, na.rm = TRUE) / var_sum)
}

compute_rho_p <- function(expr_override = NULL, pairs_df, ncores = 1) {
  expr <- as.matrix(expr_override)
  present_mask <- pairs_df$TF %in% rownames(expr) & pairs_df$gene %in% rownames(expr)
  pairs_df <- pairs_df[present_mask, , drop = FALSE]
  
  process_pair_worker <- function(ii, .pairs_df) {
    tf <- .pairs_df$TF[ii]; gene <- .pairs_df$gene[ii]
    Ai <- as.numeric(expr[tf, ]); Aj <- as.numeric(expr[gene, ])
    obs_rho <- rho_p_single(Ai, Aj)
    list(TF = tf, gene = gene, rho_p = obs_rho)
  }
  
  if (ncores > 1 && nrow(pairs_df) > 1) {
    cl <- parallel::makeCluster(ncores)
    on.exit(parallel::stopCluster(cl), add = TRUE)
    parallel::clusterExport(cl, varlist = c("rho_p_single", "expr"), envir = environment())
    res_list <- parallel::parLapply(cl, seq_len(nrow(pairs_df)), process_pair_worker, .pairs_df = pairs_df)
  } else {
    res_list <- lapply(seq_len(nrow(pairs_df)), process_pair_worker, .pairs_df = pairs_df)
  }
  
  bind_rows(res_list)
}

# Get genes needed for analysis.
needed_genes <- unique(c(tf_gene_pairs_for_modeling$TF, tf_gene_pairs_for_modeling$gene))
needed_genes <- intersect(needed_genes, rownames(GetAssayData(metacell, slot = "data")))

# Calculate rho for different cluster groupings.
results_by_cluster <- lapply(unique(metacell$broad_clusters), function(ct) {
  expr_ct <- GetAssayData(metacell, slot = "data")[needed_genes, metacell$broad_clusters == ct]
  df <- compute_rho_p(expr_override = expr_ct, pairs_df = tf_gene_pairs_for_modeling, ncores = 5)
  df$Cluster <- ct; df
})
results_broadest_clusters <- lapply(unique(metacell$broadest_cluster), function(ct) {
  expr_ct <- GetAssayData(metacell, slot = "data")[needed_genes, metacell$broadest_cluster == ct]
  df <- compute_rho_p(expr_override = expr_ct, pairs_df = tf_gene_pairs_for_modeling, ncores = 5)
  df$Cluster <- ct; df
})
results_all_together <- compute_rho_p(expr_override = GetAssayData(metacell, slot = "data")[needed_genes, ],
                                      pairs_df = tf_gene_pairs_for_modeling, ncores = 5)
results_all_together$Cluster <- "All"

# Combine and filter results to define regulons.
results_combined <- bind_rows(results_by_cluster, results_broadest_clusters, results_all_together)
results_final <- results_combined %>% 
  filter(Cluster %in% c("exh", "nonexh"), abs(rho_p) > 0.15) %>% 
  mutate(Cluster = factor(Cluster, levels=c("nonexh", "exh")))

# Remove pairs that have opposite direction of rho in exh and nonexh
flip_pairs <- results_final %>%
  filter(Cluster %in% c("nonexh", "exh")) %>%
  group_by(TF, gene) %>%
  summarise(
    nonexh_rho = mean(rho_p[Cluster == "nonexh"], na.rm = TRUE),
    exh_rho    = mean(rho_p[Cluster == "exh"], na.rm = TRUE),
    .groups = "drop"
  ) %>%
  filter(sign(nonexh_rho) != sign(exh_rho)) %>%
  select(TF, gene)

results_final <- results_final %>%
  anti_join(flip_pairs, by = c("TF", "gene"))


# Create positive and negative regulon lists.
tf_gene_lists <- results_final %>%
  group_by(TF) %>%
  dplyr::summarise(
    pos_genes = list(unique(gene[rho_p > 0])),
    neg_genes = list(unique(gene[rho_p < 0])),
    .groups = "drop"
  )
regulon_list <- list()
for(i in seq_len(nrow(tf_gene_lists))) {
  tf_name <- tf_gene_lists$TF[i]
  if(length(tf_gene_lists$pos_genes[[i]]) > 0) {
    regulon_list[[paste0(tf_name, "_pos")]] <- tf_gene_lists$pos_genes[[i]]
  }
  if(length(tf_gene_lists$neg_genes[[i]]) > 0) {
    regulon_list[[paste0(tf_name, "_neg")]] <- tf_gene_lists$neg_genes[[i]]
  }
}

# --- 9. CALCULATE AND VISUALIZE REGULON MODULE SCORES ---
# Calculate module scores using UCell.
metacell <- NormalizeData(metacell) # Revert to standard normalization for UCell.
metacell <- AddModuleScore_UCell(metacell, features=regulon_list, name = "", ncores = 7, slot="data")

# Create a heatmap of positive regulon scores across clusters.
metacell@meta.data$Cluster_names <- factor(metacell@meta.data$Cluster_names, levels = intersect(full_levels, unique(metacell@meta.data$Cluster_names)))
Idents(metacell) <- metacell$Cluster_names

regulon_score_cols <- grep("_pos$", colnames(metacell@meta.data), value=TRUE)
average_scores_df <- metacell@meta.data %>%
  dplyr::select(Cluster_names, all_of(regulon_score_cols)) %>%
  dplyr::group_by(Cluster_names) %>%
  dplyr::summarise(across(all_of(regulon_score_cols), ~mean(.x, na.rm = TRUE)))

heatmap_matrix <- average_scores_df %>%
  tibble::column_to_rownames("Cluster_names") %>% t()
rownames(heatmap_matrix) <- gsub("_pos", "", rownames(heatmap_matrix))

# TF expression annotation
tfs <- c("RBPJ", "SOX4", "TCF7", "TOX", "TOX2")

# Make sure expr_mat and metadata line up
expr_mat <- GetAssayData(metacell, layer = "data")
meta <- metacell@meta.data

# Reorder metadata to match expr_mat columns
meta <- meta[colnames(expr_mat), , drop = FALSE]
cell_clusters <- meta$Cluster_names

# Compute means in the correct cluster order
avg_expr_df <- sapply(order[order %in% cell_clusters], function(clust) {
  rowMeans(expr_mat[tfs, cell_clusters == clust, drop = FALSE], na.rm = TRUE)
})

# Transpose
avg_expr_df <- t(avg_expr_df) # clusters × TFs

# Align TF annotation to heatmap columns
avg_expr_df <- avg_expr_df[, tfs, drop = FALSE]

# Ensure cluster (row) order in TF expression matches heatmap cluster (column) order
avg_expr_df <- avg_expr_df[colnames(heatmap_matrix), , drop = FALSE]

# Top annotation
pal_tf <- paletteContinuous("fireworks")
col_fun_tf <- colorRamp2(seq(0, 1.5, length.out = length(pal_tf)), pal_tf)

# Make top expr mat
top_anno <- HeatmapAnnotation(
  df = as.data.frame(avg_expr_df),
  col = setNames(rep(list(col_fun_tf), ncol(avg_expr_df)), colnames(avg_expr_df)),
  simple_anno_size = unit(3, "mm"),
  annotation_name_side = "left",
  annotation_name_gp = gpar(fontsize = 10,fontface="italic"),
  show_legend = FALSE
)
legend_tf <- Legend(
  title = "Normalized TF\nExpr Counts",
  col_fun = col_fun_tf,
  at = c(0, 1.5),
  labels = c("0", "1.5"),
  direction = "vertical",
  legend_height = unit(1.5, "cm"),
  grid_width = unit(2.5, "mm"),
  title_gp = gpar(fontsize = 10,fontface="bold"),
  labels_gp = gpar(fontsize = 10)
)



# Define heatmap aesthetics.
pal <- paletteContinuous("solarExtra")
col_fun <- colorRamp2(seq(0, 0.3, length.out = length(pal)), pal)


# Draw heatmap
width = unit(ncol(heatmap_matrix) * 0.7, "cm")
height = unit(nrow(heatmap_matrix) * 0.6, "cm")

# Update rownames
rownames(heatmap_matrix) <- gsub("_pos","",rownames(heatmap_matrix))

# Create heatmap
ht <- Heatmap(
  heatmap_matrix,
  top_annotation = top_anno,
  row_dend_width = unit(0.25, "cm"),
  column_dend_height = unit(0.5, "cm"),
  name = "Regulon Score",
  col = col_fun,
  cluster_rows = F,
  cluster_columns = F,
  row_dend_side = "right",
  row_names_side = "left",
  border = TRUE,
  column_names_rot = 45,
  show_row_dend = TRUE,
  show_column_dend = TRUE,
  row_title = "TF Regulon",
  row_title_gp = gpar(fontsize = 14, fontface = "bold"),
  column_title = NULL,
  row_names_gp = gpar(fontsize = 12,fontface="bold"),
  column_names_gp = gpar(fontsize = 10,fontface="bold"),
  width = width,
  height = height,
  heatmap_legend_param = list(
    legend_height = unit(1.5, "cm"),
    grid_width = unit(2.5, "mm"),
    at = c(0, 0.3),
    title = "TF Regulon\nModule Score",
    title_gp = gpar(fontsize = 10,fontface="bold"),
    labels_gp = gpar(fontsize = 8)
  )
)


png(file.path(figdir,"Full_huARdb_Pos_TF_regulons.png"), width = 10, height = 6, units = "in", res = 300)

ComplexHeatmap::draw(ht,
                     heatmap_legend_side = "right",
                     annotation_legend_side = "right",
                     annotation_legend_list = list(legend_tf),
                     ht_gap = unit(0.05, "mm"),
                     legend_gap = unit(1, "mm"),
                     merge_legend = TRUE)
dev.off()

pdf(file.path(figdir,"Full_huARdb_Pos_TF_regulons.pdf"), width = 10, height = 6)
ComplexHeatmap::draw(ht,
                     heatmap_legend_side = "right",
                     annotation_legend_side = "right",
                     annotation_legend_list = list(legend_tf),
                     ht_gap = unit(0.05, "mm"),
                     legend_gap = unit(1, "mm"),
                     merge_legend = TRUE)
dev.off()



# --- 10. VISUALIZE CLUSTERS ON UMAP ---
# Load the full single-cell object for plotting.
db <- qread(file.path(figdir, "huARdb_Full_scRNA_mt7.5_full_and_tex_subclustering_umap_and_metadata.rds"))
db$cell_subtype_4 <- factor(db$cell_subtype_4, levels = intersect(full_levels, unique(db$cell_subtype_4)))
pal <- setNames(paletteDiscrete(values = levels(db$cell_subtype_4), set = "circus"), levels(db$cell_subtype_4))
md <- cbind(db[[]], Embeddings(db[["umap"]]))

# Generate and save the UMAP plot.
plot <- ggplot(md, aes(x = UMAP_1, y = UMAP_2, color = cell_subtype_4)) +
  geom_point(shape = 16, size = 0.05, alpha=0.9) +
  scale_color_manual(values = pal) +
  theme_classic(base_size = 10) +
  labs(x = "UMAP1", y = "UMAP2", color = "Cluster") +
  guides(color = guide_legend(override.aes = list(size = 2, alpha=1))) +
  coord_fixed(ratio = 1)
ggsave(plot, file = file.path(figdir, "DimPlot_fine_clustering_huARdb_Exh.png"), height = 4.5, width = 4.5, bg="white", dpi=300)
ggsave(plot, file = file.path(figdir, "DimPlot_fine_clustering_huARdb_Exh.pdf"), height = 4, width = 4)
rm(db); gc()

# --- 11. NON-NEGATIVE MATRIX FACTORIZATION (NMF) ANALYSIS ---
# Run NMF on the genes from positive regulons to find gene programs.
pos_regulons <- regulon_list[grep("_pos$", names(regulon_list))]
nmf_genes <- unique(unlist(pos_regulons))

metacell <- runNMF(
  metacell, assay = "RNA", slot = "data", k = 9, new.reduction = "NMF",
  seed = 123, L1 = c(0.35, 0), hvg = nmf_genes, center = TRUE, scale = TRUE
)

# Extract top genes contributing to each NMF program.
nmf_loadings <- metacell@reductions[["NMF"]]@feature.loadings
normalized_loadings <- apply(nmf_loadings, 2, function(col) ifelse(sum(col) > 0, col / sum(col), col))
list_of_top_genes <- lapply(colnames(normalized_loadings), function(factor_name) {
  sorted_vector <- sort(normalized_loadings[, factor_name], decreasing = TRUE)
  names(sorted_vector)[cumsum(sorted_vector) <= 0.8]
})
names(list_of_top_genes) <- colnames(normalized_loadings)

# Visualize similarity between NMF programs using a Jaccard index heatmap.
programs <- list_of_top_genes
similarity_matrix <- matrix(0, nrow = length(programs), ncol = length(programs), dimnames = list(names(programs), names(programs)))
for (i in 1:length(programs)) {
  for (j in i:length(programs)) {
    jaccard_sim <- length(intersect(programs[[i]], programs[[j]])) / length(union(programs[[i]], programs[[j]]))
    similarity_matrix[i, j] <- similarity_matrix[j, i] <- jaccard_sim
  }
}
pheatmap(
  similarity_matrix, main = "Pairwise Similarity of NMF Programs",
  clustering_method = "ward.D2", display_numbers = round(similarity_matrix, 2),
  fontsize_number = 15, number_color = "white", cellwidth = 40, cellheight = 40
)



# Get the NMF loadings and TF regulons 
nmf_names <- c(
  "Exhaustion",
  "NFkB Signaling",
  "Activation/Stress Response",
  "Cell Cycle",
  "Terminal Effector",
  "Stemness",
  "Effector",
  "Membrane Remodeling",
  "Interferon Response"
)
# Create a named mapping vector: names are NMF_1 ... NMF_8
nmf_map <- setNames(nmf_names, paste0("NMF_", seq_along(nmf_names)))

loadings <- metacell@reductions[["NMF"]]@feature.loadings
regulons <- pos_regulons
tf_names <- names(regulons)
nmf_programs <- colnames(loadings)


# Score the NMF gene programs in the metacell object.
metacell <- AddModuleScore_UCell(metacell, features = list_of_top_genes, name = "", ncores = 4)



# --- 12. VISUALIZE NMF PROGRAM EXPRESSION PER GENE ---
# Create an expression heatmap of NMF program genes.
metacell$Cluster_names <- factor(metacell$Cluster_names, levels = intersect(full_levels, unique(metacell$Cluster_names)))
Idents(metacell) <- metacell$Cluster_names

# Prepare data and annotations for the heatmap.
genes_to_plot <- unique(unlist(list_of_top_genes))
expr_matrix <- GetAssayData(metacell, assay="RNA", slot="data")[genes_to_plot, ]
scaled_expr <- t(scale(t(sapply(levels(metacell$Cluster_names), function(clust) {
  rowMeans(expr_matrix[, WhichCells(metacell, idents = clust), drop = FALSE])
}))))
scaled_expr[is.na(scaled_expr)] <- 0

# Define program and TF metadata for annotations.
all_programs <- names(list_of_top_genes)
program_name_map <- setNames(names(list_of_top_genes), all_programs) # Simple 1:1 map for now
final_order <- names(list_of_top_genes) # Use default NMF order
target_tfs <- c("RBPJ_pos", "TCF7_pos", "SOX4_pos", "TOX_pos", "TOX2_pos")
tf_colors <- c("RBPJ"="#000436", "SOX4"="#1632FB", "TCF7"="#C732D5", "TOX"="#FDB31A", "TOX2"="#A31D1D")

# Collect all genes to plot and map them to their respective programs and TF targets.
genes_to_plot <- c()
gene_program_map <- c()
tf_annotation_list <- list(RBPJ=c(), SOX4=c(), TCF7=c(), TOX=c(), TOX2=c())
for (prog in all_programs) {
  genes_in_program <- intersect(list_of_top_genes[[prog]], rownames(metacell))
  human_readable_name <- program_name_map[prog]
  genes_to_plot <- c(genes_to_plot, genes_in_program)
  gene_program_map <- c(gene_program_map, rep(human_readable_name, length(genes_in_program)))
  for (tf in target_tfs) {
    tf_name <- gsub("_pos", "", tf)
    is_regulated_text <- ifelse(genes_in_program %in% pos_regulons[[tf]], "Target", "Not Target")
    tf_annotation_list[[tf_name]] <- c(tf_annotation_list[[tf_name]], is_regulated_text)
  }
}

# Create top annotation for clusters (columns).
cluster_levels <- levels(metacell$Cluster_names)
top_annot_df <- data.frame(Cluster = factor(colnames(scaled_expr), levels = cluster_levels), row.names = colnames(scaled_expr))
cluster_palette <- setNames(paletteDiscrete(values = cluster_levels, set = "circus"), cluster_levels)
top_annotation_clusters <- HeatmapAnnotation(df = top_annot_df, col = list(Cluster = cluster_palette),
                                             show_annotation_name = TRUE, annotation_name_side = "left")

# Create right annotation for programs and TF binding (rows).
tf_order <- c("RBPJ", "SOX4", "TCF7", "TOX", "TOX2")
row_annot_df <- as.data.frame(tf_annotation_list, stringsAsFactors = FALSE)[, tf_order]
row_annot_df$Program <- factor(gene_program_map, levels = final_order)
for(tf in tf_order) {
  row_annot_df[[tf]] <- factor(row_annot_df[[tf]], levels = c("Target", "Not Target"))
}
tf_color_map <- lapply(tf_order, function(tf) setNames(c(tf_colors[tf], "grey95"), c("Target", "Not Target")))
names(tf_color_map) <- tf_order
program_palette <- setNames(viridis::turbo(length(names(list_of_top_genes))), final_order)
combined_colors <- c(list(Program = program_palette), tf_color_map)
row_annotation_all <- rowAnnotation(df = row_annot_df, col = combined_colors, show_annotation_name = TRUE)

# Define row and column splits for the heatmap.
program_split <- factor(gene_program_map, levels = final_order)
split_index <- which(cluster_levels == "ITGAE+ Trm")
column_group_vector <- c(rep("Non-Exhausted", split_index), 
                         rep("Exhausted", length(cluster_levels) - split_index))
column_split_groups <- factor(column_group_vector, levels = c("Non-Exhausted", "Exhausted"))

# Define color function for the heatmap body.
cols <- paletteContinuous("blueYellow")
col_fun <- colorRamp2(seq(-2, 2, length.out = length(cols)), cols)

# Create the final ComplexHeatmap object.
ht <- Heatmap(
  scaled_expr, use_raster = TRUE, raster_quality = 10, name = "Z-Scaled Expr",
  cluster_columns = FALSE, column_split = column_split_groups,
  cluster_rows = FALSE, row_split = program_split,
  right_annotation = row_annotation_all, top_annotation = top_annotation_clusters,
  show_row_names = FALSE, show_column_names = FALSE,
  column_gap = unit(1, "mm"), row_gap = unit(0.5, "mm"), border = TRUE,
  row_title=NULL, col = col_fun
)

# Save the final heatmap.
png(file.path(figdir, "huARdb_avg_pos_NMF_Program_Genes_Heatmap.png"),
    width = 5.25, height = 4.5, units = "in", res = 300)
ComplexHeatmap::draw(ht, heatmap_legend_side = "right", annotation_legend_side = "right")
dev.off()
pdf(file.path(figdir, "huARdb_avg_pos_NMF_Program_Genes_Heatmap.pdf"),
    width = 5.25, height = 4.5)
ComplexHeatmap::draw(ht, heatmap_legend_side = "right", annotation_legend_side = "right")
dev.off()

# --- 13. SUMMARY STATISTICS ---
# Calculate the proportion of genes in each NMF program bound by each TF.
tf_order <- c("RBPJ", "SOX4", "TCF7", "TOX", "TOX2")
proportion_bound <- row_annot_df %>%
  group_by(Program) %>%
  summarise(across(all_of(tf_order), ~ mean(.x == "Target"), .names = "{col}"))
print(proportion_bound)





# --- 12. VISUALIZE NMF PROGRAM EXPRESSION AS A MODULE SCORE VIOLIN PLOT ---


# Rename metadata columns based on the map
for (orig_col in names(nmf_map)) {
  # Get the desired new column name from the map
  new_col <- nmf_map[[orig_col]]
  
  # Create the new column with the data from the original column.
  metacell@meta.data[[new_col]] <- metacell@meta.data[[orig_col]]
}

# Prepare data for ggplot 
# Extract the metadata and the newly named NMF scores into a data frame.
# This now works because 'nmf_names' is defined.
plot_data <- metacell@meta.data %>%
  select(Cluster_names, all_of(nmf_names))

# Reshape the data from wide to long format
plot_data_long <- plot_data %>%
  pivot_longer(
    cols = all_of(nmf_names),
    names_to = "Program",
    values_to = "Score"
  )

# Set the factor levels for the programs to ensure the correct plotting order.
# This now works because 'prog_order' is defined above.
plot_data_long$Program <- factor(plot_data_long$Program, levels = prog_order)

# Create the color palette and the plot
# This now works because 'nmf_names' is defined.
pal <- setNames(viridis::turbo(length(nmf_names)), nmf_names)

stacked_vln_plot <- ggplot(plot_data_long, aes(x = Cluster_names, y = Score, fill = Program)) +
  geom_violin(scale = "width", trim = TRUE, show.legend = FALSE, size = 0.2, width = 0.8) +
  geom_hline(yintercept = 0, color = "black", linewidth = 0.5) +
  
  # Facet by program with a free y-axis for each
  facet_grid(rows = vars(Program), scales = "free") +
  
  # Ensure 0 appears in every facet's y-axis
  geom_blank(aes(y = 0)) +
  
  # Apply the color palette
  scale_fill_manual(values = pal) +
  
  # Set theme and labels
  theme_classic() +
  theme(
    panel.spacing = unit(0.5, "lines"),
    strip.background = element_blank(),
    strip.text.y = element_text(size = 10, angle = 0, hjust = 0, face = "bold", color = "black"),
    axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5, size = 8, color = "black"),
    axis.text.y = element_text(size = 8, color = "black"),
    axis.title.y = element_text(size = 10, face="bold", color = "black"),
    axis.title.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.line.x = element_blank()
  ) +
  # Add breaks to the y-axis for better readability
  scale_y_continuous(breaks = scales::breaks_width(0.2))

# Display the plot
print(stacked_vln_plot)

# Save the plot 
ggsave(
  stacked_vln_plot,
  file = file.path(figdir, "Stacked_NMF_Program_Violin_Plot.png"),
  height = 8, width = 6.5, units = "in", bg = "white", dpi = 300
)

ggsave(
  stacked_vln_plot,
  file = file.path(figdir, "Stacked_NMF_Program_Violin_Plot.pdf"),
  height = 8, width = 6.5, units = "in"
)


