#==================================================================================================
# R SCRIPT FOR FIGURE 6 ANALYSIS
# DATE: October 03, 2025
#
# DESCRIPTION:
# This script performs a comparative analysis of binding sites and target gene effects for
# JUN, FOSL1, BATF, and a DESynR domain-swapped TF (JUN.FOS.BATF). The analysis includes:
# 1.  HOMER motif enrichment analysis plot.
# 2.  Heatmap visualization of normalized peak signals across TFs to identify co-binding patterns.
# 3.  Quantification and plotting of peak counts for various TF binding combinations.
# 4.  Identification of gene targets for co-bound sites by integrating peak data with promoter
#     and enhancer annotations.
# 5.  Differential gene expression analysis and heatmap visualization of target genes to assess
#     the functional impact of TF binding.
#==================================================================================================

# --- 1. LOAD REQUIRED LIBRARIES ---
# Suppress package startup messages for a cleaner console output.
suppressPackageStartupMessages({
  library(data.table)
  library(dplyr)
  library(tidyr)
  library(tibble)
  library(stringr)
  library(purrr)
  library(janitor)
  library(ggplot2)
  library(ComplexHeatmap)
  library(circlize)
  library(viridis)
  library(GenomicRanges)
  library(TxDb.Hsapiens.UCSC.hg38.knownGene)
  library(org.Hs.eg.db)
  library(AnnotationDbi)
  
  # Differential expression analysis
  library(DESeq2)
  
  # Text mining for plot labels
  library(tidytext)
})

# --- 2. DEFINE GENERALIZABLE FILE PATHS ---
base_dir <- "/path/to/your/project/directory"

# Construct input and output directories from the base path.
motif_dir <- file.path(base_dir, "HOMER/HOMER_motif_analysis")
norm_peak_matrix_file <- file.path(base_dir, "normalized_peak_matrices/combined_long_format_normalized_peak_matrix.csv")
output_dir <- file.path(base_dir, "OUTPUT_DIR")
fig_dir <- file.path(output_dir, "FIGS_DIR")
all_sig_file <- file.path(base_dir, "HOMER_annotations_COMBINED_all_Group_vs_Control_results.csv")
specific_peaks_file <- file.path(base_dir, "group_specific_peaks_summary.csv")
rna_dds_file <- file.path(base_dir, "RNA_dds.rds")
engreitz_pairs_file <- file.path(base_dir, <Supplementary table 2 path>) # ENCODE-rE2G annotations (supplementary table 2) 

# Create output directories if they do not already exist.
dir.create(output_dir, recursive = TRUE, showWarnings = FALSE)
dir.create(fig_dir, recursive = TRUE, showWarnings = FALSE)

# --- 3. HOMER MOTIF ENRICHMENT PLOTTING ---
# Find all HOMER known motif result files recursively.
motif_result_files <- list.files(motif_dir, pattern = "knownResults.txt", recursive = TRUE, full.names = TRUE)

# Read and combine all motif result files into a single data.table.
motif_results_list <- lapply(motif_result_files, function(file) {
  dt <- fread(file, select = c("Motif Name", "P-value", "Log P-value", "q-value (Benjamini)",
                               "% of Target Sequences with Motif", "% of Background Sequences with Motif"))
  group <- basename(dirname(file)) %>% str_remove("_motif_output$") %>% str_trim()
  dt[, group_name := group]
  return(dt)
})
motif_results <- rbindlist(motif_results_list) %>% janitor::clean_names()

# Define the desired order for TF groups on the plot.
group_order_plots <- c("JUN", "FOSL1", "BATF", "JUN.FOS.BATF", "FOSL1.BATF.MAFA",
                       "BATF3.BATF2.MAFF", "BATF3.JDP2.BATF2", "MAFF.ATF3.BATF2")

# Filter and process motif data to select the top enriched motifs for each group.
motif_plot_data <- motif_results %>%
  mutate(neglogP = -log_p_value,
         motif_name_clean = toupper(str_extract(motif_name, "^[^/]+")),
         group_name = factor(group_name, levels = group_order_plots)) %>%
  filter(neglogP > 50, !is.na(group_name)) %>%
  group_by(group_name) %>%
  arrange(desc(neglogP), .by_group = TRUE) %>%
  # Prioritize showing the most enriched bZIP motifs.
  {
    best_bzip <- filter(., str_detect(motif_name_clean, regex("bZIP", ignore_case = TRUE))) %>% slice_head(n = 3)
    non_bzip <- filter(., !str_detect(motif_name_clean, regex("bZIP", ignore_case = TRUE)))
    bind_rows(best_bzip, non_bzip)
  } %>%
  slice_max(order_by = neglogP, n = 10, with_ties = FALSE) %>%
  ungroup() %>%
  mutate(motif_y = tidytext::reorder_within(motif_name_clean, neglogP, group_name),
         is_bzip = if_else(str_detect(motif_name_clean, regex("bZIP", ignore_case = TRUE)), "bZIP", "Other"))

# Generate the motif enrichment bar plot.
motif_bar_plot <- ggplot(motif_plot_data, aes(x = neglogP, y = motif_y, fill = is_bzip)) +
  geom_col(width = 0.7, color = "black", linewidth = 0.25) +
  tidytext::scale_y_reordered() +
  facet_wrap(~ group_name, scales = "free_y", ncol = 2) +
  scale_fill_manual(values = c("bZIP" = "#4B0082", "Other" = "grey80")) +
  scale_x_continuous(expand = c(0, 0.05)) +
  labs(x = expression(-log[10](P) ~ "enrichment"), y = NULL, fill = NULL) +
  theme_bw(base_size = 10) +
  theme(strip.text = element_text(face = "bold", size = 10),
        strip.background = element_blank(),
        axis.text = element_text(color = "black", size = 8, face = "bold"),
        panel.grid = element_blank(),
        panel.border = element_blank(),
        axis.line = element_line(color = "black", linewidth = 0.3))

# Save the plot.
ggsave(file.path(fig_dir, "homer_top_motifs_plot_filtered_to_top3_bzip.png"),
       motif_bar_plot, width = 8, height = 10, dpi = 300, bg = "white")
ggsave(file.path(fig_dir, "homer_top_motifs_plot_filtered_to_top3_bzip.pdf"),
       motif_bar_plot, width = 8, height = 10, bg = "white")

# --- 4. HEATMAP OF JUN, FOSL1, AND BATF PEAK SIGNALS ---
# Load peak data and normalized peak signal matrix.
all_sig <- fread(all_sig_file)
jfb_peaks <- all_sig %>% filter(group %in% c("JUN.FOS.BATF", "JUN", "FOSL1", "BATF")) %>% pull(peak_id)

combined_norm_matrix <- fread(norm_peak_matrix_file, nThread = 10)
combined_norm_matrix_filter <- combined_norm_matrix %>%
  filter(source_group %in% c("JUN.FOS.BATF", "JUN", "FOSL1", "BATF")) %>%
  filter(group %in% c("JUN.FOS.BATF", "JUN", "FOSL1", "BATF", "HyPBase")) %>%
  filter(peak_id %in% jfb_peaks) %>%
  mutate(log_count = log2(normalized_count + 1)) %>%
  select(peak_id, group, log_count)

# Merge overlapping peaks to create a consensus peak set for the heatmap.
df_gr <- combined_norm_matrix_filter %>%
  separate(peak_id, into = c("chr", "start", "end"), sep = "[:\\-]", convert = TRUE)
gr <- makeGRangesFromDataFrame(df_gr, keep.extra.columns = TRUE)
gr_merged <- reduce(gr, ignore.strand = TRUE)

# Map original peak counts to the merged peaks.
hits <- findOverlaps(gr, gr_merged)
df_map <- data.frame(
  merged_peak = paste0(seqnames(gr_merged)[subjectHits(hits)], ":", start(gr_merged)[subjectHits(hits)], "-", end(gr_merged)[subjectHits(hits)]),
  group = mcols(gr)$group[queryHits(hits)],
  log_count = mcols(gr)$log_count[queryHits(hits)]
)
merged_counts <- df_map %>%
  group_by(merged_peak, group) %>%
  summarise(log_count = sum(log_count), .groups = "drop")

# Create and Z-score scale the heatmap matrix.
heatmap_mat <- merged_counts %>%
  pivot_wider(names_from = merged_peak, values_from = log_count, values_fill = 0) %>%
  column_to_rownames(var = "group") %>%
  as.matrix()
row_order <- c("JUN", "FOSL1", "BATF", "JUN.FOS.BATF", "HyPBase")
heatmap_mat <- heatmap_mat[row_order, , drop = FALSE]
heatmap_mat_z <- apply(heatmap_mat, 2, function(x) if (sd(x) == 0) rep(0, length(x)) else scale(x)[,1])

# --- 5. DEFINE AND VISUALIZE TF BINDING COMBINATIONS ---
# Define the combination of TFs binding at each merged peak.
split_groups <- setdiff(rownames(heatmap_mat_z), "HyPBase")
get_group_combo <- function(values, groups) {
  active <- groups[values[groups] > 0]; if (length(active) == 0) "None" else paste(sort(active), collapse = "+")
}
col_combos <- apply(heatmap_mat_z, 2, get_group_combo, groups = split_groups)
combo_levels <- c(unlist(lapply(1:length(split_groups), function(k) combn(split_groups, k, FUN = function(x) paste(sort(x), collapse = "+")))), "None")
col_combos <- factor(col_combos, levels = combo_levels)

# Define heatmap annotations for TF combination size.
combo_size <- sapply(as.character(col_combos), function(x) if (x == "None") 0 else length(strsplit(x, "\\+")[[1]]))
combo_colors <- setNames(viridis(4, option = "turbo"), as.character(1:4))
top_anno <- HeatmapAnnotation(
  `Combo Size` = factor(combo_size, levels = names(combo_colors)),
  col = list(`Combo Size` = combo_colors),
  show_annotation_name = TRUE, annotation_name_side = "left"
)

# Generate and save the full heatmap of co-binding patterns.
ht <- Heatmap(
  heatmap_mat_z, name = "Z-score", col = paletteContinuous("solarExtra"),
  border = TRUE, use_raster = TRUE, raster_quality = 10,
  column_split = col_combos, cluster_columns = FALSE, cluster_rows = FALSE,
  show_column_names = FALSE, top_annotation = top_anno, column_title = NULL,
  row_names_gp = gpar(fontsize = 8, fontface = "bold")
)
png(file.path(fig_dir, "JUN_FOS_BATF_Peaks_Heatmap.png"), width = 10, height = 2, units = "in", res = 300)
draw(ht, heatmap_legend_side = "right", annotation_legend_side = "right", merge_legend = TRUE)
dev.off()
pdf(file.path(fig_dir, "JUN_FOS_BATF_Peaks_Heatmap.pdf"), width = 10, height = 2)
draw(ht, heatmap_legend_side = "right", annotation_legend_side = "right", merge_legend = TRUE)
dev.off()

# Generate a filtered heatmap showing only single-TF and JFB-containing combinations.
cols_to_keep <- sapply(as.character(col_combos), function(x) (length(strsplit(x, "\\+")[[1]]) == 1) | grepl("JUN.FOS.BATF", x))
heatmap_mat_z_filtered <- heatmap_mat_z[, cols_to_keep, drop = FALSE]
col_combos_filtered <- col_combos[cols_to_keep]
combo_size_filtered <- combo_size[cols_to_keep]
top_anno_filtered <- HeatmapAnnotation(`Combo Size` = factor(combo_size_filtered, levels = names(combo_colors)),
                                       col = list(`Combo Size` = combo_colors), show_annotation_name = TRUE, annotation_name_side = "left")
ht_filtered <- Heatmap(heatmap_mat_z_filtered, name = "Z-score", col = paletteContinuous("solarExtra"),
                       border = TRUE, use_raster = TRUE, raster_quality = 10,
                       column_split = col_combos_filtered, cluster_columns = FALSE, cluster_rows = FALSE,
                       show_column_names = FALSE, top_annotation = top_anno_filtered, column_title = NULL,
                       row_names_gp = gpar(fontsize = 8, fontface = "bold"))
png(file.path(fig_dir, "only_JUN.FOS.BATF_combos_JUN_FOS_BATF_Peaks_Heatmap.png"), width = 10, height = 2, units = "in", res = 300)
draw(ht_filtered, heatmap_legend_side = "right", annotation_legend_side = "right", merge_legend = TRUE)
dev.off()
pdf(file.path(fig_dir, "only_JUN.FOS.BATF_combos_JUN_FOS_BATF_Peaks_Heatmap.pdf"), width = 10, height = 2)
draw(ht_filtered, heatmap_legend_side = "right", annotation_legend_side = "right", merge_legend = TRUE)
dev.off()

# --- 6. QUANTIFY AND PLOT PEAK COUNTS PER COMBINATION ---
# Create a bar plot showing the number of peaks in each TF binding combination.
columns_per_split <- tibble(column_combo = names(table(col_combos)), n_columns = as.numeric(table(col_combos))) %>%
  filter(column_combo != "None") %>%
  mutate(combo_size = sapply(as.character(column_combo), function(x) length(strsplit(x, "\\+")[[1]])))
p <- ggplot(columns_per_split, aes(x = column_combo, y = n_columns, fill = factor(combo_size))) +
  geom_bar(stat = "identity", color = "black", linewidth = 0.25, width = 0.5) +
  scale_fill_manual(values = combo_colors, name = "Combo Size") +
  labs(x = "TF Combination", y = "Peaks") +
  theme_minimal(base_size = 10) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.line = element_line(color = "black"), panel.grid = element_blank()) +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 4000))
ggsave(file.path(fig_dir, "total_peaks_per_combination.png"), plot = p, width = 6, height = 4, bg = "white", dpi = 300)
ggsave(file.path(fig_dir, "total_peaks_per_combination.pdf"), plot = p, width = 6, height = 4)

# Create a similar bar plot for the filtered (JFB-containing) combinations.
columns_per_split_filtered <- tibble(column_combo = names(table(col_combos_filtered)), n_columns = as.numeric(table(col_combos_filtered))) %>%
  filter(column_combo != "None", n_columns != 0) %>%
  mutate(combo_size = sapply(as.character(column_combo), function(x) length(strsplit(x, "\\+")[[1]])))
p_filtered <- ggplot(columns_per_split_filtered, aes(x = column_combo, y = n_columns, fill = factor(combo_size))) +
  geom_bar(stat = "identity", color = "black", linewidth = 0.25, width = 0.5) +
  scale_fill_manual(values = combo_colors, name = "Combo Size") +
  labs(x = "TF Combination", y = "Peaks") +
  theme_minimal(base_size = 12) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.line = element_line(color = "black"), panel.grid = element_blank()) +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 4000))
ggsave(file.path(fig_dir, "JUN.FOS.BATF_combos_only_total_peaks_per_combination.png"), plot = p_filtered, width = 6, height = 4, bg = "white", dpi = 300)
ggsave(file.path(fig_dir, "JUN.FOS.BATF_combos_only_total_peaks_per_combination.pdf"), plot = p_filtered, width = 6, height = 4)


# --- 7. IDENTIFY GENE TARGETS OF CO-BOUND SITES ---
# Identify genes linked to JFB peaks that are also co-bound by JUN or BATF.
dt <- fread(engreitz_pairs_file) %>% distinct(enh_coord, chr, start, end, gene_name)
se_rna <- readRDS(rna_dds_file); rna_mat <- assay(se_rna)
tf_groups <- toupper(c("BATF", "JUN", "JUN.FOS.BATF"))
annot <- fread(all_sig_file) %>% mutate(group = toupper(group))
make_gr <- function(df) makeGRangesFromDataFrame(df %>% separate(peak_id, into = c("chr", "start", "end"), sep = "[:-]", convert = TRUE), keep.extra.columns = TRUE)
gr_list <- lapply(tf_groups, function(tf) make_gr(annot %>% filter(group == tf)))
names(gr_list) <- tf_groups

# Find JFB peaks that overlap with JUN or BATF peaks.
hits_jun <- findOverlaps(gr_list[["JUN.FOS.BATF"]], gr_list[["JUN"]])
hits_batf <- findOverlaps(gr_list[["JUN.FOS.BATF"]], gr_list[["BATF"]])
jfb_overlap <- gr_list[["JUN.FOS.BATF"]][unique(c(queryHits(hits_jun), queryHits(hits_batf)))]
names(jfb_overlap) <- paste0(seqnames(jfb_overlap), ":", start(jfb_overlap), "-", end(jfb_overlap))

# Link these co-bound peaks to genes via enhancer and promoter databases.
enhancer_db_gr <- makeGRangesFromDataFrame(dt, seqnames.field = "chr", start.field = "start", end.field = "end", keep.extra.columns = TRUE)
enh_hits <- findOverlaps(jfb_overlap, enhancer_db_gr)
enhancer_pairs <- data.frame(acr_id = names(jfb_overlap[queryHits(enh_hits)]),
                             gene = mcols(enhancer_db_gr)$gene_name[subjectHits(enh_hits)], is_enhancer = TRUE, is_promoter = FALSE)

txdb <- TxDb.Hsapiens.UCSC.hg38.knownGene; genes_gr <- genes(txdb)
gene_map <- AnnotationDbi::select(org.Hs.eg.db, keys = genes_gr$gene_id, columns = "SYMBOL", keytype = "ENTREZID")
mcols(genes_gr)$gene_symbol <- gene_map$SYMBOL[match(genes_gr$gene_id, gene_map$ENTREZID)]
genes_gr <- genes_gr[!is.na(mcols(genes_gr)$gene_symbol) & mcols(genes_gr)$gene_symbol %in% rownames(rna_mat)]
promoter_windows <- promoters(genes_gr, upstream = 500, downstream = 500)
prom_hits <- findOverlaps(jfb_overlap, promoter_windows)
promoter_pairs <- data.frame(acr_id = names(jfb_overlap[queryHits(prom_hits)]),
                             gene = mcols(promoter_windows)$gene_symbol[subjectHits(prom_hits)], is_promoter = TRUE, is_enhancer = FALSE)

# Consolidate all pairs and annotate with TF binding information.
all_pairs <- bind_rows(promoter_pairs, enhancer_pairs) %>%
  group_by(acr_id, gene) %>%
  summarise(is_promoter = any(is_promoter), is_enhancer = any(is_enhancer), .groups = "drop") %>%
  mutate(annotation = case_when(is_promoter & is_enhancer ~ "Promoter_Enhancer",
                                is_promoter & !is_enhancer ~ "Promoter",
                                !is_promoter & is_enhancer ~ "Enhancer", TRUE ~ "Other"))
tf_binding_info <- tibble(acr_id = names(jfb_overlap))
for (tf in tf_groups) {
  bound_acrs <- names(jfb_overlap[unique(queryHits(findOverlaps(jfb_overlap, gr_list[[tf]])))])
  tf_binding_info[[tf]] <- as.integer(tf_binding_info$acr_id %in% bound_acrs)
}
all_model_results_final <- all_pairs %>%
  left_join(tf_binding_info, by = "acr_id") %>%
  filter(JUN.FOS.BATF == 1 & (JUN == 1 | BATF == 1))

# --- 8. DIFFERENTIAL GENE EXPRESSION ANALYSIS OF TARGETS ---
# Map binding group names to RNA-seq condition names.
group_to_tf_map <- c("JUN.FOS.BATF" = "cJUN_cFOS_BATF", "BATF" = "BATF", "MAFF.ATF3.BATF2" = "MAFF_ATF3_BATF2",
                     "BATF3.BATF2.MAFF" = "BATF3_BATF2_MAFF", "BATF3.JDP2.BATF2" = "BATF3_JDP2_BATF2",
                     "FOSL1.BATF.MAFA" = "FOSL1_BATF_MAFA", "JUN" = "JunB", "FOSL1" = "FOSL1", "CAR_GFP" = "CAR_GFP")

# Load RNA-seq data and calculate log2 fold changes.
rna <- readRDS(rna_dds_file)
dds_rna_res <- rna
control_group <- "CAR_GFP"
conditions_to_test <- setdiff(unique(dds_rna_res$TF), control_group)
rna_results_list <- lapply(conditions_to_test, function(cond) {
  res <- results(dds_rna_res, contrast = c("TF", cond, control_group))
  list(l2fc = setNames(res$log2FoldChange, rownames(res)), padj = setNames(res$padj, rownames(res)))
})
log2fc_rna <- do.call(cbind, lapply(rna_results_list, `[[`, "l2fc"))
colnames(log2fc_rna) <- paste0(conditions_to_test, "_vs_", control_group)

# Identify DEGs
FDR_cutoff <- 0.05; logfc_cutoff <- 0.75
rna_sig_df <- map_dfr(conditions_to_test, ~{
  results(dds_rna_res, contrast = c("TF", .x, control_group)) %>%
    as.data.frame() %>% rownames_to_column("gene") %>%
    filter(!is.na(padj), padj <= FDR_cutoff, abs(log2FoldChange) >= logfc_cutoff) %>%
    mutate(comparison_v_cargfp = .x)
})

# Define gene sets based on TF binding combinations.
tfs <- c("JUN", "BATF", "JUN.FOS.BATF")
tf_combos <- unlist(lapply(1:length(tfs), function(k) combn(tfs, k, simplify = FALSE)), recursive = FALSE)
gene_sets_df <- map_dfr(tf_combos, function(tf_subset) {
  list(combo = paste(tf_subset, collapse = "_"),
       genes = list(all_model_results_final %>% filter(if_all(all_of(tf_subset), ~ .x == 1)) %>% pull(gene) %>% unique()))
})

# Function to plot log2fc
plot_log2fc_heatmap <- function(mat, out_prefix, plot_title, 
                                interesting_genes, row_km = 4, 
                                color_function) {
  # --- Prepare matrix ---
  mat_for_clustering <- as.matrix(mat)
  mat_for_clustering[is.na(mat_for_clustering)] <- 0
  mat_for_clustering <- pmax(pmin(mat_for_clustering, 1), -1)

  # --- Perform clustering ---
  set.seed(123)
  row_km_ctrs <- min(row_km, nrow(mat_for_clustering))
  km_row_assign <- kmeans(mat_for_clustering, centers = row_km_ctrs,
                          nstart = 25, iter.max = 50)$cluster

  # --- Optional: order row clusters by "JUN.FOS.BATF" mean ---
  cluster_means <- tapply(mat_for_clustering[, "JUN.FOS.BATF"], km_row_assign, mean)
  cluster_order <- order(cluster_means, decreasing = TRUE)
  km_row_assign <- factor(km_row_assign, levels = cluster_order)

  # --- Reorder rows by cluster assignment ---
  order_idx <- order(km_row_assign)
  mat_ordered <- mat_for_clustering[order_idx, , drop = FALSE]
  km_split_vector <- km_row_assign[order_idx]

  # --- Only label interesting_genes present in this matrix ---
  interesting_genes_present <- intersect(interesting_genes, rownames(mat_ordered))
  if (length(interesting_genes_present) > 0) {
    idx <- match(interesting_genes_present, rownames(mat_ordered))
    ha <- rowAnnotation(
      mark = anno_mark(
        at = idx,
        labels = interesting_genes_present,
        labels_gp = gpar(fontsize = 7),
        padding = unit(2, "mm")
      ),
      annotation_name_side = "top"
    )
  } else {
    ha <- NULL
  }

  # --- Build the heatmap ---
  ht <- Heatmap(
    mat_ordered,
    name                  = plot_title,
    col                   = color_function,
    row_split             = km_split_vector,
    column_split          = colnames(mat_ordered), 
    cluster_rows          = TRUE,
    cluster_row_slices    = FALSE,
    cluster_columns       = FALSE,
    right_annotation      = ha,
    show_row_dend         = FALSE,
    show_row_names        = FALSE,
    row_gap               = unit(0.75, "mm"),
    column_gap            = unit(0.75, "mm"),
    border                = "black",
    row_title             = NULL,
    column_title          = NULL,
    column_names_gp       = gpar(fontsize = 8, fontface = "bold"),
    heatmap_legend_param  = list(
      title     = "Log2FC",
      title_gp  = gpar(fontsize = 7, fontface = "bold"),
      labels_gp = gpar(fontsize = 7),
      at        = c(-1, 0, 1),
      labels    = c("≤-1", "0", "≥1")
    )
  )

  # --- Save plots ---
  png(paste0(out_prefix, ".png"), width = 2.75, height = 5, units = "in", res = 300)
  ComplexHeatmap::draw(ht)
  dev.off()

  pdf(paste0(out_prefix, ".pdf"), width = 2.75, height = 5)
  ComplexHeatmap::draw(ht)
  dev.off()

  cat("Saved Log2FC heatmap to:", out_prefix, "\n")
  
  # --- Return  info ---
  return(list(
    total_genes_plotted = nrow(mat_ordered),
    interesting_genes_requested = length(interesting_genes),
    interesting_genes_found = length(interesting_genes_present),
    interesting_genes_labeled = interesting_genes_present
  ))
}

# Define genes to label (your existing list)
interesting_genes_list <- c(
  "GZMA", "GZMH", "GZMB", "GZMK", "PDCD1", "TIGIT", "TNFRSF9", "RUNX1", "RUNX3",
  "NFATC3", "NFIL3", "BCL2", "FAS", "PRDM1", "KLRD1", "KLRG1", "LEF1", "BACH2",
  "HAVCR2", "IL2RA", "IL12RB1", "IL12RB2", "ID2", "ID3", "NFKB1", "NFKBIZ",
  "BCL11B", "KLF7", "MYB", "FOXP1", "IL7R", "SOX4", "RUNX2", "IFNG", "TNF", "IKZF3",
  "IKZF2", "IKZF1", "CSF1", "FASLG", "PRF1", "BATF3", "IRF4", "IRF2", "KLRC1", "KLRC2","BATF3",
  "IRF1", "CD28", "CTLA4", "KLF6", "KLF2", "TOX", "TOX2", "TCF7", "ICOS", "LAG3", "TIGIT",
  "PDCD1", "TNFRSF9", "TNF", "FASLG", "BHLHE40", "ARID5B", "FYN", "GZMB",
  "IL2RA", "IL2RB", "IRF4", "NKG7", "TCF7", "FOSL1", "JUN", "BATF", "CCL5", "GZMA",
  "GZMH", "PRF1", "LAG3", "ZAP70", "KLRG1", "OAS1", "OAS2", "RUNX1", "RUNX2", "RUNX3",
  "SLAMF6", "TANK", "XCL2", "RBPJ", "NFATC3", "NFAT5", "FAS", "PRDM1", "BACH2", "ID2",
  "ID3", "NFKB1", "FOXP1", "IL7R", "SOX4", "RELA", "FOS", "IFNG", "IKZF2", "IRF2",
  "KLRC2", "KLRC1", "IRF1", "CD28", "CTLA4", "TOX", "TOX2", "ICOS", "TIGIT", "CD69",
  "LEF1", "CCR7", "FOXO1", "STAT5A", "STAT5B", "HIF1A", "IKZF3", "SNX9", "FUT8", "PIK3CD",
  "AHR", "LAYN", "PIK3C2B", "KAT6A",
  "BTLA","CBLB","GNLY","ICOS", "IL13", "IL23R", "IL26", "IL4", "IL5", "IL23R", "KLRD1",
  "LEF1","SATB1","SLAMF7","SOX4","TLR2","WNT7B","ZBTB32","CXCR4","IL2RA","CD69","PIK3CA","TNFRSF1B", 
  "BATF3","CD63","TGFB3","PDCD1LG2","CBLB","GNLY","FCGR3A","TNFRSF1A","TNFSF10",
  "PPP3CC","LEF1",
  "SRF","BIRC2","BCL2A1","FOXN3","CSF2","IFI16","DEK","CASP1","ITGA4","ITGA2","ZC3H12A"
)
# Remove duplicates and sort for easier inspection
interesting_genes_list <- unique(interesting_genes_list)
interesting_genes_list <- sort(interesting_genes_list)


# Define variables
all_model_results_final_degs <- list()

degs_df <- rna_sig_df # Use the full significant results data frame for filtering
control_name <- "CAR_GFP"
combo_to_filter <- c("JUN_JUN.FOS.BATF", "BATF_JUN.FOS.BATF", "JUN_BATF_JUN.FOS.BATF")
all_model_results_final_degs <- list()

for (combo in combo_to_filter) {
  message(sprintf("--- Processing combo: %s ---", combo))
  
  # 1. Get the full set of genes for this binding combination
  group_genes <- gene_sets_df %>% 
    filter(combo == !!combo) %>% 
    pull(genes) %>% 
    unlist() %>% 
    unique()
  
  cat(sprintf("Step 1: Found %d total genes with the '%s' binding signature.\n", length(group_genes), combo))

  # 2. Identify DEGs specific to THIS combo's conditions
  tf_names_in_combo <- strsplit(combo, "_")[[1]]
  rna_conditions_in_combo <- unname(group_to_tf_map[tf_names_in_combo])
  
  combo_specific_degs <- degs_df %>%
    filter(comparison_v_cargfp %in% rna_conditions_in_combo) %>%
    pull(gene) %>%
    unique()
  
  cat(sprintf("Step 2: Found %d unique DEGs across conditions specific to this combo (%s).\n", length(combo_specific_degs), paste(rna_conditions_in_combo, collapse=", ")))

  # 3. Filter the binding-defined genes to keep only the ones that are also DEGs
  final_genes_to_plot <- intersect(group_genes, combo_specific_degs)
  
  cat(sprintf("Step 3: After filtering, %d genes remain to be plotted.\n", length(final_genes_to_plot)))

  if (length(final_genes_to_plot) == 0) {
    message("No overlapping genes found for this combo after filtering. Skipping.\n")
    next
  }

  # 4. Prepare the matrix for plotting
  contrast_names <- paste0(rna_conditions_in_combo, "_vs_", control_name)
  available_contrasts <- intersect(contrast_names, colnames(log2fc_rna))
  log2fc_rna_plot <- log2fc_rna[final_genes_to_plot, available_contrasts, drop = FALSE]

  # Rename columns back to binding names for clarity
  colnames(log2fc_rna_plot) <- sapply(colnames(log2fc_rna_plot), function(x) {
    base <- sub("_vs_.*$", "", x)
    binding_name <- names(group_to_tf_map)[group_to_tf_map == base]
    if (length(binding_name) > 0) binding_name[1] else base
  })

  # 5. Call the  plotting function
  plot_log2fc_heatmap(
    mat = log2fc_rna_plot,
    out_prefix = file.path(output_dir, paste0("log2FC_RNA_", combo)),
    plot_title = paste0("RNA_", combo),
    interesting_genes = interesting_genes_list,
    color_function = color_fun_rna,
    row_km = min(4, nrow(log2fc_rna_plot))
  )
  
  # Store results
  all_model_results_final_degs[[combo]] <- all_model_results_final %>% 
    filter(gene %in% rownames(log2fc_rna_plot)) %>% 
    distinct(acr_id, gene)
    
  message(sprintf("Finished processing for %s. Plotted %d genes.\n", combo, nrow(log2fc_rna_plot)))
}
