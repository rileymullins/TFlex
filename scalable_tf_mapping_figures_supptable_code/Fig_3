#==================================================================================================
# R SCRIPT FOR FIGURE 3 ANALYSIS
# DATE: October 03, 2025
#
# DESCRIPTION:
# This script analyzes enhancer-gene pairs to identify co-regulated and TF-bound elements.
# Key steps include:
# 1.  Defining enhancer-gene pairs from promoter proximity and an enhancer database.
# 2.  Identifying which pairs are bound by specific transcription factors (TFs).
# 3.  Performing linear regression and correlation analysis to find dynamic pairs.
# 4.  Adding back promoter-bound genes that were not in the original pairs.
# 5.  Generating paired heatmaps of RNA expression and ATAC accessibility for TF-specific gene sets.
# 6.  Conducting permutation and Fisher's exact tests for TF binding enrichment at enhancers.
#==================================================================================================

# --- 1. LOAD LIBRARIES ---
suppressPackageStartupMessages({
  library(tidyverse)
  library(data.table)
  library(GenomicRanges)
  library(TxDb.Hsapiens.UCSC.hg38.knownGene)
  library(org.Hs.eg.db)
  library(future)
  library(future.apply)
  library(progressr)
  library(broom)
  library(ComplexHeatmap)
  library(circlize)
  library(viridis)
  library(scales)
  library(eulerr)
  library(grid) 
  library(regioneR) 
})

# --- 2. DEFINE FILE PATHS AND DIRECTORIES ---
input_dir <- "./input"
output_dir <- "./output"
figdir <- file.path(output_dir, "figures")
dir.create(figdir, recursive = TRUE, showWarnings = FALSE)

# Define subdirectories for specific analysis outputs.
bulk_rna_dir <- file.path(output_dir, "wherry_bulk_rna_seq_analysis")
bulk_atac_dir <- file.path(output_dir, "wherry_bulk_atac_analysis")
bzip_results_outdir <- file.path(bulk_atac_dir, "bZIP_combined_linear_regression")
dir.create(bzip_results_outdir, recursive = TRUE, showWarnings = FALSE)

# --- 3. INITIAL DATA LOADING AND SETUP ---
# Define promoter window size.
promoter_upstream <- 5000
promoter_downstream <- 5000

# Load pre-defined enhancer-gene pairs from an external database.
dt <- fread(file=file.path(input_dir, "distinct_gene_pairs_unmerged_final.csv"), nThread = 12) %>%  # ENCODE-rE2G annotations (supplementary table 2) 
  distinct(enh_coord, chr, start, end, gene_name)

# Load and combine TF peak annotations for acute and chronic conditions.
annot_ac <- read.csv(file.path(input_dir, "HOMER_annotations_COMBINED_all_Group_vs_Control_results_acute.csv"))
annot_ch <- read.csv(file.path(input_dir, "HOMER_annotations_COMBINED_all_Group_vs_Control_results_chronic.csv"))
annot <- rbind(annot_ac, annot_ch)

# Load MultiAssayExperiment object containing paired RNA and ATAC data.
mae_paired <- readRDS(file = file.path(bulk_atac_dir, "wherry_data_paired_rna_atac_multi_assay_experiment.rds"))

# --- 4. EXTRACT AND PREPARE EXPRESSION/ACCESSIBILITY MATRICES ---
# Extract RNA and ATAC SummarizedExperiment objects.
se_rna <- mae_paired[["rna"]]
se_atac <- mae_paired[["atac"]]
colnames(se_atac) <- mae_paired[["atac"]]$RNA_ID # Align sample names.

# Extract matrices and process row names.
atac_mat <- assay(se_atac)
rna_mat <- assay(se_rna)
rownames(rna_mat) <- rowData(se_rna)$geneSymbol
rna_mat <- rna_mat[!duplicated(rownames(rna_mat)), ] # Remove duplicate gene symbols.

# Load and format Accessible Chromatin Region (ACR) annotations.
group_annotation_file <- file.path(bulk_atac_dir, "all_acrs_HOMER_annotated.txt")
acr_annot <- fread(group_annotation_file) %>%
  rename_with(~ gsub(" ", "_", .)) %>%
  dplyr::mutate(acr_id = paste0(Chr, "_", Start, "_", End)) %>%
  dplyr::select(acr_id, Chr, Start, End) %>%
  distinct()

# --- 5. IDENTIFY TF-BOUND ACCESSIBLE CHROMATIN REGIONS (ACRs) ---
# Function to find overlaps between TF peaks and a universe of regions (all ACRs).
get_universe_overlaps <- function(tf_peak_df, universe_gr, maxgap = 0) {
    if (nrow(tf_peak_df) == 0) return(character(0))
    tf_gr <- tf_peak_df %>%
        separate(peak_id, into = c("chr", "start", "end"), sep = "[_:-]", convert = TRUE, fill = "right") %>%
        filter(!is.na(chr) & !is.na(start) & !is.na(end)) %>%
        makeGRangesFromDataFrame()
    hits <- findOverlaps(tf_gr, universe_gr, maxgap = maxgap)
    unique(mcols(universe_gr)$peak_id[subjectHits(hits)])
}

# Create a GRanges object for all ACRs.
all_acrs_gr <- acr_annot %>%
  mutate(peak_id = acr_id) %>%
  dplyr::rename(chr = Chr, start = Start, end = End) %>%
  makeGRangesFromDataFrame(keep.extra.columns = TRUE)

# Define TF groups of interest.
tf_groups <- c("TOX_Acute", "TCF7_Acute", "TOX2_Acute", "SOX4_Acute", "RBPJ_Acute",
               "TOX_Chronic", "TCF7_Chronic", "TOX2_Chronic", "SOX4_Chronic")

# Identify all ACRs bound by any of the specified TFs.
tf_bound_acrs_list <- lapply(tf_groups, function(tf) {
  peaks_df <- annot %>% filter(group == tf)
  get_universe_overlaps(peaks_df, all_acrs_gr)
})
tf_bound_acrs <- unique(unlist(tf_bound_acrs_list))
all_acrs_gr <- all_acrs_gr[mcols(all_acrs_gr)$peak_id %in% tf_bound_acrs]

cat("Using", length(tf_groups), "TFs:", paste(tf_groups, collapse=", "), "\n")
cat("Found", length(tf_bound_acrs), "unique TF-bound ACRs to use for pairing\n")

# --- 6. DEFINE CANDIDATE ACR-GENE PAIRS ---
# Load human gene annotations.
txdb <- TxDb.Hsapiens.UCSC.hg38.knownGene
genes_gr <- genes(txdb)
gene_map <- AnnotationDbi::select(org.Hs.eg.db, keys = genes_gr$gene_id, columns = "SYMBOL", keytype = "ENTREZID")
mcols(genes_gr)$gene_symbol <- gene_map$SYMBOL[match(genes_gr$gene_id, gene_map$ENTREZID)]
genes_gr <- genes_gr[!is.na(mcols(genes_gr)$gene_symbol) & mcols(genes_gr)$gene_symbol %in% rownames(rna_mat)]

# Pair 1: ACRs overlapping promoter windows.
promoter_windows <- promoters(genes_gr, upstream = promoter_upstream, downstream = promoter_downstream)
promoter_hits <- findOverlaps(all_acrs_gr, promoter_windows)
promoter_pairs <- data.frame(
  acr_id = mcols(all_acrs_gr)$peak_id[queryHits(promoter_hits)],
  gene_name = mcols(promoter_windows)$gene_symbol[subjectHits(promoter_hits)]
) %>% distinct()

# Pair 2: ACRs overlapping known enhancer regions.
enhancer_db_gr <- makeGRangesFromDataFrame(dt, seqnames.field = "chr", start.field = "start", end.field = "end", keep.extra.columns = TRUE)
enhancer_hits <- findOverlaps(all_acrs_gr, enhancer_db_gr)
enhancer_pairs <- data.frame(
  acr_id = mcols(all_acrs_gr)$peak_id[queryHits(enhancer_hits)],
  gene_name = mcols(enhancer_db_gr)$gene_name[subjectHits(enhancer_hits)]
) %>% distinct()

# Combine promoter and enhancer pairs and annotate them.
all_candidate_pairs <- bind_rows(promoter_pairs, enhancer_pairs) %>%
  distinct(acr_id, gene_name)
acr_gene_pairs_for_modeling <- all_candidate_pairs %>%
  mutate(is_promoter = (paste(acr_id, gene_name) %in% paste(promoter_pairs$acr_id, promoter_pairs$gene_name))) %>%
  mutate(is_enhancer = (paste(acr_id, gene_name) %in% paste(enhancer_pairs$acr_id, enhancer_pairs$gene_name)))

# --- 7. ANNOTATE PAIRS WITH TF BINDING INFORMATION ---
# Create a binary matrix indicating which TFs bind to which ACRs.
tf_binding_info <- tibble(acr_id = tf_bound_acrs)
for (tf in tf_groups) {
  this_list <- tf_bound_acrs_list[[which(tf_groups == tf)]]
  tf_binding_info[[tf]] <- as.integer(tf_bound_acrs %in% this_list)
}

# Join TF binding info with the candidate pairs.
acr_gene_pairs_for_modeling <- acr_gene_pairs_for_modeling %>%
  left_join(tf_binding_info, by = "acr_id") %>%
  filter(gene_name %in% rownames(rna_mat))

cat("\nFinal number of unique ACR-gene pairs for modeling:", nrow(acr_gene_pairs_for_modeling), "\n")
cat("Number of unique ACRs in the final set:", length(unique(acr_gene_pairs_for_modeling$acr_id)), "\n")
cat("Number of unique genes in the final set:", length(unique(acr_gene_pairs_for_modeling$gene_name)), "\n\n")
print(table(Promoter = acr_gene_pairs_for_modeling$is_promoter, Enhancer = acr_gene_pairs_for_modeling$is_enhancer))

# Save the comprehensive modeling table.
write.csv(acr_gene_pairs_for_modeling, file = file.path(figdir, "ALL_ACUTE_AND_CHRONIC_TFs_acr_gene_pairs_for_modeling.csv"), row.names = FALSE)
acr_gene_pairs_for_modeling <- read.csv(file = file.path(figdir, "ALL_ACUTE_AND_CHRONIC_TFs_acr_gene_pairs_for_modeling.csv"))

# --- 8. LINEAR REGRESSION AND CORRELATION ANALYSIS ---
# Filter RNA and ATAC matrices to include only paired ACRs and genes.
paired_acrs <- unique(acr_gene_pairs_for_modeling$acr_id)
paired_genes <- unique(acr_gene_pairs_for_modeling$gene_name)
rna_mat_filter <- rna_mat[paired_genes, , drop = FALSE]
atac_mat_filter <- atac_mat[paired_acrs, , drop = FALSE]
common_samps <- intersect(colnames(rna_mat_filter), colnames(atac_mat_filter))
if (length(common_samps) == 0) stop("No common samples between RNA and ATAC matrices.")
rna_mat_filter <- rna_mat_filter[, common_samps, drop = FALSE]
atac_mat_filter <- atac_mat_filter[, common_samps, drop = FALSE]

# Set up parallel processing.
plan(multisession, workers = 10)
handlers(global = TRUE)
handlers("progress")

# Process pairs in batches to manage memory.
batch_size <- 10000
n_pairs <- nrow(acr_gene_pairs_for_modeling)
n_batches <- ceiling(n_pairs / batch_size)
all_model_results <- list()

# Loop through batches and perform regression for each pair.
with_progress({
  p_overall <- progressor(along = 1:n_batches)
  for (batch_i in 1:n_batches) {
    message(sprintf("Processing batch %d of %d", batch_i, n_batches))
    start_idx <- (batch_i - 1) * batch_size + 1
    end_idx <- min(batch_i * batch_size, n_pairs)
    batch_pairs <- acr_gene_pairs_for_modeling[start_idx:end_idx, ]
    
    batch_results <- future_lapply(1:nrow(batch_pairs), function(i) {
      pair <- batch_pairs[i, ]
      gene <- pair$gene_name
      acr <- pair$acr_id
      if (!(gene %in% rownames(rna_mat_filter)) || !(acr %in% rownames(atac_mat_filter))) {
        return(NULL)
      }
      expr_vec <- as.numeric(rna_mat_filter[gene, ])
      peak_vec <- as.numeric(atac_mat_filter[acr, ])
      df <- data.frame(gene_expression = expr_vec, peak_accessibility = peak_vec)
      
      # Linear model: gene expression ~ peak accessibility.
      fit <- tryCatch(lm(gene_expression ~ peak_accessibility, data = df), error = function(e) NULL)
      if (is.null(fit)) return(NULL)
      
      model_info <- broom::glance(fit)
      tidy_coef <- broom::tidy(fit) %>%
        filter(term == "peak_accessibility") %>%
        transmute(
          gene = gene, acr_id = acr, beta = estimate, p_value = p.value,
          r_squared = model_info$r.squared, adj_r_squared = model_info$adj.r.squared
        )
      
      # Spearman correlation test.
      cor_test <- suppressWarnings(cor.test(expr_vec, peak_vec, method = "spearman"))
      tidy_coef$spearman_rho <- cor_test$estimate
      tidy_coef$spearman_p <- cor_test$p.value
      tidy_coef
    }, future.seed = TRUE)
    
    all_model_results[[batch_i]] <- do.call(rbind, Filter(Negate(is.null), batch_results))
    p_overall(sprintf("Completed batch %d/%d", batch_i, n_batches))
    gc() # Garbage collection to free memory.
  }
})
plan(sequential) # Return to sequential processing.

# --- 9. PROCESS AND FILTER MODELING RESULTS ---
# Combine results from all batches and adjust p-values.
all_model_results_merged <- dplyr::bind_rows(all_model_results) %>%
  group_by(gene) %>%
  dplyr::mutate(fdr_lm = p.adjust(p_value, method = "BH"),
                fdr_spearman = p.adjust(spearman_p, method = "BH")) %>%
  ungroup() %>%
  dplyr::select(gene, acr_id, r_squared, beta, fdr_lm, spearman_rho, fdr_spearman) %>%
  arrange(desc(abs(beta)), fdr_lm)

# Join modeling results with TF binding and annotation info.
final_annotated_results <- all_model_results_merged %>%
  left_join(acr_gene_pairs_for_modeling, by = c("gene" = "gene_name", "acr_id" = "acr_id")) %>%
  dplyr::mutate(
    annotation = case_when(
      is_promoter == TRUE & is_enhancer == TRUE ~ "Promoter_Enhancer",
      is_promoter == TRUE & is_enhancer == FALSE ~ "Promoter",
      is_promoter == FALSE & is_enhancer == TRUE ~ "Enhancer",
      TRUE ~ "Other"
    )
  )

# Summarize TF binding counts across all pairs.
tf_summary <- final_annotated_results %>%
  dplyr::select(all_of(tf_groups)) %>%
  dplyr::summarise_all(~sum(., na.rm = TRUE)) %>%
  pivot_longer(cols = everything(), names_to = "Transcription_Factor", values_to = "Count") %>%
  arrange(desc(Count))
print(tf_summary)

# Save unfiltered results.
write.csv(final_annotated_results, file = file.path(figdir, "ALL_ACUTE_AND_CHRONIC_final_annotated_results_from_acr_gene_pairs_for_modeling.csv"))
final_annotated_results <- read.csv(file = file.path(figdir, "ALL_ACUTE_AND_CHRONIC_final_annotated_results_from_acr_gene_pairs_for_modeling.csv"))

# Apply statistical and effect size filters to identify dynamic pairs.
all_model_results_final <- final_annotated_results %>%
  filter(fdr_lm < 0.05 & fdr_spearman < 0.05 & beta > 0.15 & r_squared > 0.15) %>%
  dplyr::mutate(
    abs_rho = abs(spearman_rho),
    abs_beta = abs(beta),
    acr_gene = paste0(acr_id, "_x_", gene)
  )
nrow(all_model_results_final)

# Summarize TF binding counts for the filtered dynamic pairs.
tf_summary <- all_model_results_final %>%
  dplyr::select(all_of(tf_groups)) %>%
  dplyr::summarise_all(~sum(., na.rm = TRUE)) %>%
  pivot_longer(cols = everything(), names_to = "Transcription_Factor", values_to = "Count") %>%
  arrange(desc(Count))
print(tf_summary)

# Save filtered results.
write.csv(all_model_results_final, file = file.path(figdir, "ALL_ACUTE_AND_CHRONIC_FILTERED_final_annotated_results_from_acr_gene_pairs_for_modeling.csv"))
all_model_results_final <- read.csv(file = file.path(figdir, "ALL_ACUTE_AND_CHRONIC_FILTERED_final_annotated_results_from_acr_gene_pairs_for_modeling.csv"))

# --- 10. ADD BACK PROMOTER-BOUND GENES ---
# Identify genes with TF binding in their promoter but not found through ACR pairing.
new_rows_list <- list()
promoter_1kb_gr <- promoters(genes_gr, upstream = 1000, downstream = 1000)
for (tf in tf_groups) {
  tf_peak_df <- annot %>% filter(group == tf)
  if (nrow(tf_peak_df) == 0) next
  tf_gr <- tf_peak_df %>%
    separate(peak_id, into = c("chr", "start", "end"), sep = "[_:-]", convert = TRUE, fill = "right") %>%
    filter(!is.na(chr) & !is.na(start) & !is.na(end)) %>%
    makeGRangesFromDataFrame()
  hits <- findOverlaps(tf_gr, promoter_1kb_gr)
  if (length(hits) == 0) next
  
  promoter_bound_genes_for_this_tf <- unique(mcols(promoter_1kb_gr)$gene_symbol[subjectHits(hits)])
  new_genes_to_add <- promoter_bound_genes_for_this_tf
  
  if (length(new_genes_to_add) > 0) {
    message(sprintf("For TF '%s', found %d new gene(s) with promoter binding.", tf, length(new_genes_to_add)))
    new_df <- tibble(
      gene = new_genes_to_add,
      acr_id = NA_character_,
      annotation = "non_acr_promoter"
    )
    new_df[[tf]] <- 1
    new_rows_list[[tf]] <- new_df
  }
}

# Combine and add these new promoter-bound genes to the main results.
all_new_rows <- bind_rows(new_rows_list)
final_new_rows <- all_new_rows %>%
  group_by(gene, acr_id, annotation) %>%
  dplyr::summarise(across(all_of(tf_groups), ~sum(., na.rm = TRUE)), .groups = "drop")

all_model_results_final <- bind_rows(all_model_results_final, final_new_rows)
write.csv(all_model_results_final, file = file.path(figdir, "with_promoter_genes_added_back_ALL_ACUTE_AND_CHRONIC_FILTERED_final_annotated_results_from_acr_gene_pairs_for_modeling.csv"))
all_model_results_final <- read.csv(file = file.path(figdir, "with_promoter_genes_added_back_ALL_ACUTE_AND_CHRONIC_FILTERED_final_annotated_results_from_acr_gene_pairs_for_modeling.csv"))

# --- 11. VISUALIZE OVERLAPS WITH EULER DIAGRAMS ---
# Venn/Euler diagram for TOX and TCF7 target genes.
tox_targets <- all_model_results_final %>% filter(TOX_Acute == 1, !is.na(acr_id)) %>% pull(gene) %>% unique()
tcf7_targets <- all_model_results_final %>% filter(TCF7_Acute == 1, !is.na(acr_id)) %>% pull(gene) %>% unique()
p <- plot(euler(list(TCF7 = tcf7_targets, TOX = tox_targets)),
          fills = list(fill = c("skyblue", "orange"), alpha = 0.7),
          labels = list(font = 2), quantities = TRUE)
ggsave(file.path(figdir, "venn_diagram_tox_tcf7_genes.png"), plot = p, width = 4, height = 3, dpi = 300)
ggsave(file.path(figdir, "venn_diagram_tox_tcf7_genes.pdf"), plot = p, width = 4, height = 3)

# Venn/Euler diagram for TOX and TCF7 target ACR-gene pairs.
tox_targets <- all_model_results_final %>% filter(TOX_Acute == 1, !is.na(acr_id)) %>% pull(acr_gene) %>% unique()
tcf7_targets <- all_model_results_final %>% filter(TCF7_Acute == 1, !is.na(acr_id)) %>% pull(acr_gene) %>% unique()
p <- plot(euler(list(TCF7 = tcf7_targets, TOX = tox_targets)),
          fills = list(fill = c("skyblue", "orange"), alpha = 0.7),
          labels = list(font = 2), quantities = TRUE)
ggsave(file.path(figdir, "venn_diagram_tox_tcf7_peak_gene_pairs.png"), plot = p, width = 4, height = 3, dpi = 300)
ggsave(file.path(figdir, "venn_diagram_tox_tcf7_peak_gene_pairs.pdf"), plot = p, width = 4, height = 3)

# Venn/Euler diagram for TOX and TCF7 bound ACRs.
tox_targets <- all_model_results_final %>% filter(TOX_Acute == 1, !is.na(acr_id)) %>% pull(acr_id) %>% unique()
tcf7_targets <- all_model_results_final %>% filter(TCF7_Acute == 1, !is.na(acr_id)) %>% pull(acr_id) %>% unique()
p <- plot(euler(list(TCF7 = tcf7_targets, TOX = tox_targets)),
          fills = list(fill = c("skyblue", "orange"), alpha = 0.7),
          labels = list(font = 2), quantities = TRUE)
ggsave(file.path(figdir, "venn_diagram_tox_tcf7_acrs.png"), plot = p, width = 4, height = 3, dpi = 300)
ggsave(file.path(figdir, "venn_diagram_tox_tcf7_acrs.pdf"), plot = p, width = 4, height = 3)

# --- 12. PLOT TCF7 AND TOX EXPRESSION IN BULK RNA-SEQ DATA ---
genes_of_interest <- c("TCF7", "TOX")
cluster_order <- c("Naive", "SCM-R3-", "SCM-R3+", "CM", "EM1", "EM2", "EMRA", "PD1+CD39+")

# Prepare data for plotting.
plot_data_bulk <- rna_mat[genes_of_interest, , drop = FALSE] %>%
  t() %>% as.data.frame() %>%
  rownames_to_column(var = "SampleID") %>%
  left_join(as.data.frame(colData(se_rna)) %>% rownames_to_column(var = "SampleID"), by = "SampleID") %>%
  pivot_longer(cols = all_of(genes_of_interest), names_to = "Gene", values_to = "Expression") %>%
  dplyr::mutate(Cluster = factor(Cell_Subset, levels = cluster_order),
                Gene = factor(Gene, levels = c("TCF7", "TOX")))

# Generate and save the boxplot.
turbo_palette <- setNames(viridis::turbo(length(cluster_order)), cluster_order)
expression_plot <- ggplot(plot_data_bulk, aes(x = Cluster, y = Expression, fill = Cluster)) +
  geom_boxplot(outlier.shape = NA, width = 0.75, alpha = 0.8) +
  geom_jitter(size = 0.25, width = 0.2, alpha = 0.5) +
  facet_wrap(~Gene, scales = "free", ncol = 2) +
  theme_minimal() +
  labs(y = "Normalized Expression", x = NULL) +
  theme(
    axis.title = element_text(color = "black", size = 10, face = "bold"),
    axis.text.y = element_text(color = "black", size = 10),
    axis.text.x = element_text(color = "black", size = 10, angle = 45, hjust = 1),
    strip.text = element_text(color = "black", size = 10, face = "bold"),
    panel.grid = element_blank(),
    axis.line = element_line(color = "black"),
    legend.position = "none"
  ) +
  scale_fill_manual(values = turbo_palette)
ggsave(file.path(figdir, "TOX_TCF7_Bulk_Expr.png"), expression_plot, width = 5, height = 2.5, dpi = 300, bg = "white")
ggsave(file.path(figdir, "TOX_TCF7_Bulk_Expr.pdf"), expression_plot, width = 5, height = 2.5, bg = "white")

# --- 13. GENERATE PAIRED ATAC AND RNA HEATMAPS ---
# Define gene sets: TOX-specific, TCF7-specific, and common targets.
outdir <- file.path(figdir, "heatmaps_by_set")
dir.create(outdir, recursive = TRUE, showWarnings = FALSE)
tox_targets  <- all_model_results_final %>% filter(TOX_Acute == 1, !is.na(acr_id)) %>% pull(acr_gene) %>% unique()
tcf7_targets <- all_model_results_final %>% filter(TCF7_Acute == 1, !is.na(acr_id)) %>% pull(acr_gene) %>% unique()
sets_list <- list(
  TCF7_specific = all_model_results_final %>% filter(acr_gene %in% setdiff(tcf7_targets, tox_targets)),
  TOX_specific  = all_model_results_final %>% filter(acr_gene %in% setdiff(tox_targets, tcf7_targets)),
  Common        = all_model_results_final %>% filter(acr_gene %in% intersect(tcf7_targets, tox_targets))
)

# Define heatmap parameters.
n_rows_per_set <- sapply(sets_list, function(df) nrow(df %>% distinct(acr_id, gene)))
n_rows_max <- max(n_rows_per_set, 1)
n_cols <- ncol(rna_mat)
cell_width <- unit(0.2, "mm")
cell_height <- unit(0.14, "mm")
total_heatmap_width  <- n_cols * cell_width
total_heatmap_height <- n_rows_max * cell_height

# Loop through each gene set to generate and save a paired heatmap.
for (set_name in names(sets_list)) {
  message("Processing set: ", set_name)
  filtered_data <- sets_list[[set_name]]
  if (nrow(filtered_data) == 0) {
    message("  Skipping empty set: ", set_name); next
  }

  # Subset and Z-score scale matrices.
  atac_mat_sub <- atac_mat[filtered_data$acr_id, , drop = FALSE]
  rna_mat_sub  <- rna_mat[filtered_data$gene, , drop = FALSE]
  row_zscores <- function(mat, limits = c(-2, 2)) {
    z <- t(scale(t(mat))); z[z > limits[2]] <- limits[2]; z[z < limits[1]] <- limits[1]; z
  }
  atac_z <- row_zscores(atac_mat_sub)
  rna_z  <- row_zscores(rna_mat_sub)

  # Order columns by cell subset.
  coldata_df <- as.data.frame(colData(mae_paired)) %>%
    dplyr::mutate(Cell_Subset = factor(Cell_Subset, levels = cell_subset_order)) %>%
    filter(!is.na(Cell_Subset))
  ordered_cols_df <- coldata_df %>% arrange(Cell_Subset)
  atac_z_ordered <- atac_z[, ordered_cols_df$ATAC_ID, drop = FALSE]
  rna_z_ordered  <- rna_z[, ordered_cols_df$RNA_ID,  drop = FALSE]

  # Perform k-means clustering on columns (samples) to group them.
  set.seed(1); k <- 3
  km_result_cols <- kmeans(t(rna_z_ordered), centers = k, nstart = 50)
  
  # Reorder columns based on clustering result.
  col_cluster_df <- data.frame(ATAC_ID = colnames(atac_z_ordered), cluster = km_result_cols$cluster) %>%
    left_join(ordered_cols_df, by = "ATAC_ID") %>%
    arrange(cluster, Cell_Subset)
  final_col_order_atac <- col_cluster_df$ATAC_ID
  final_col_order_rna  <- col_cluster_df$RNA_ID
  atac_z_col_ordered <- atac_z_ordered[, final_col_order_atac, drop = FALSE]
  rna_z_col_ordered  <- rna_z_ordered[, final_col_order_rna,  drop = FALSE]

  # Perform k-means clustering on rows (pairs) to group by expression pattern.
  mean_rna_in_naive <- rowMeans(rna_z_col_ordered[, col_cluster_df$RNA_ID[col_cluster_df$Cell_Subset == "Naive"]], na.rm = TRUE)
  set.seed(1); km_result_rows <- kmeans(rna_z_ordered, centers = 2, nstart = 50)
  cluster_means <- tapply(mean_rna_in_naive, km_result_rows$cluster, mean)
  high_expr_cluster <- names(which.max(cluster_means))
  low_expr_cluster  <- names(which.min(cluster_means))
  
  # Order rows within clusters for visualization.
  rows_high <- which(km_result_rows$cluster == high_expr_cluster)
  rows_low  <- which(km_result_rows$cluster == low_expr_cluster)
  sorted_high <- rows_high[order(mean_rna_in_naive[rows_high], decreasing = TRUE)]
  sorted_low  <- rows_low[order(mean_rna_in_naive[rows_low], decreasing = TRUE)]
  final_row_order <- c(sorted_high, sorted_low)
  
  atac_final_reordered <- atac_z_col_ordered[final_row_order, , drop = FALSE]
  rna_final_reordered  <- rna_z_col_ordered[final_row_order, , drop = FALSE]
  row_split_factor <- factor(c(rep("Naive", length(sorted_high)), rep("Effector", length(sorted_low))), levels = c("Naive", "Effector"))

  # Define annotations for heatmap.
  cluster_color_mapping <- setNames(viridis::turbo(length(cell_subset_order)), cell_subset_order)
  final_col_annotation <- HeatmapAnnotation(`Cell Subset` = col_cluster_df$Cell_Subset,
                                            col = list(`Cell Subset` = cluster_color_mapping),
                                            show_annotation_name = FALSE)
  
  # Create heatmaps for ATAC and RNA data.
  pal_atac <- paletteContinuous("blueYellow"); pal_rna <- paletteContinuous("horizonExtra")
  color_fun_atac <- colorRamp2(seq(-2, 2, length.out = length(pal_atac)), pal_atac)
  color_fun_rna <- colorRamp2(seq(-2, 2, length.out = length(pal_rna)), pal_rna)
  
  ht_atac <- Heatmap(atac_final_reordered, name = "ATAC Z-Score", col = color_fun_atac,   
     width = total_heatmap_width,
    height = total_heatmap_height,

                     top_annotation = final_col_annotation, cluster_columns = FALSE, show_row_names = FALSE,
                     show_column_names = FALSE, column_split = col_cluster_df$cluster, row_split = row_split_factor,
                     column_title = "ATAC Peak Signal", use_raster = TRUE, raster_quality = 10)
                     
  ht_rna <- Heatmap(rna_final_reordered, name = "RNA Z-Score", col = color_fun_rna,
     width = total_heatmap_width,
    height = total_heatmap_height,
                    top_annotation = final_col_annotation, cluster_columns = FALSE, show_row_names = FALSE,
                    show_column_names = FALSE, column_split = col_cluster_df$cluster, row_title = NULL,
                    column_title = "RNA Gene Expr", use_raster = TRUE, raster_quality = 10)
                    
  # Draw and save the combined heatmap.
  png(file.path(outdir, paste0("peak_gene_links_matched_heatmap_", set_name, ".png")),
      width = 5, height = 6.5, units = "in", res = 300)
  ComplexHeatmap::draw(ht_atac + ht_rna,
       heatmap_legend_side = "right",
       annotation_legend_side = "right",
       ht_gap                 = unit(0.05, "mm"),
       legend_gap             = unit(0.5, "mm"),
       merge_legend = TRUE)
  dev.off()
  
  pdf(file.path(outdir, paste0("peak_gene_links_matched_heatmap_", set_name, ".pdf")),
      width = 10, height = 10) 
  ComplexHeatmap::draw(ht_atac + ht_rna,
       heatmap_legend_side = "right",
       annotation_legend_side = "right",
       ht_gap                 = unit(0.05, "mm"),
       legend_gap             = unit(0.5, "mm"),
       merge_legend = TRUE)
  dev.off()
}

# --- 14. STATISTICAL TESTS FOR TF BINDING AT ENHANCERS ---
# Summarize TF counts in enhancer regions before and after filtering.
enhancer_counts_before <- final_annotated_results %>%
  distinct(acr_id, .keep_all = TRUE) %>% filter(is_enhancer) %>%
  summarise(across(all_of(tf_groups), ~sum(., na.rm = TRUE))) %>%
  pivot_longer(everything(), names_to = "TF", values_to = "Count")
cat("--- TF Counts in Enhancer Regions (Before Filtering) ---\n"); print(enhancer_counts_before)

enhancer_counts_after <- all_model_results_final %>%
  distinct(acr_id, .keep_all = TRUE) %>% filter(is_enhancer) %>%
  summarise(across(all_of(tf_groups), ~sum(., na.rm = TRUE))) %>%
  pivot_longer(everything(), names_to = "TF", values_to = "Count")
cat("\n--- TF Counts in Enhancer Regions (After Filtering) ---\n"); print(enhancer_counts_after)

# Fisher's Exact Test for co-binding of TOX and TCF7 at enhancers.
binding_summary <- all_model_results_final %>%
  mutate(bound_by_TOX = (TOX_Acute == 1), bound_by_TCF7 = (TCF7_Acute == 1))

enhancer_acrs_df <- binding_summary %>%
  distinct(acr_id, .keep_all = TRUE) %>%
  filter(is_enhancer == TRUE)

total_enhancers <- nrow(enhancer_acrs_df)
tox_bound <- enhancer_acrs_df %>% filter(bound_by_TOX) %>% pull(acr_id)
tcf7_bound <- enhancer_acrs_df %>% filter(bound_by_TCF7) %>% pull(acr_id)

a <- length(intersect(tox_bound, tcf7_bound)) # Both
b <- length(setdiff(tox_bound, tcf7_bound))   # TOX only
c <- length(setdiff(tcf7_bound, tox_bound))   # TCF7 only
d <- total_enhancers - (a + b + c)            # Neither

contingency_matrix <- matrix(c(a, c, b, d), nrow = 2,
                             dimnames = list(TOX = c("Bound", "Not Bound"), TCF7 = c("Bound", "Not Bound")))
fisher_result <- fisher.test(contingency_matrix, alternative = "greater")

print("Contingency Table for Enhancer Co-binding:"); print(contingency_matrix); print(fisher_result)

# Permutation test for enrichment of TOX and TCF7 peaks at the set of TCF7-bound dynamic enhancers.
enhancer_acrs_gr <- enhancer_acrs_df %>%
  separate(acr_id, into = c("chr", "start", "end"), sep = "_", convert = TRUE) %>%
  makeGRangesFromDataFrame(keep.extra.columns = TRUE)

tf_peaks_gr_list <- lapply(c("TOX_Acute", "TCF7_Acute"), function(tf) {
  annot %>% filter(group == tf) %>%
    separate(peak_id, into = c("chr", "start", "end"), sep = "[_:-]", convert = TRUE) %>%
    makeGRangesFromDataFrame()
})
names(tf_peaks_gr_list) <- c("TOX_Acute", "TCF7_Acute")

plan(multisession, workers = 10)
perm_results <- future_lapply(names(tf_peaks_gr_list), function(tf) {
  pt <- overlapPermTest(
    A = resize(tf_peaks_gr_list[[tf]], width = 1, fix = "center"), # Use peak summits
    B = enhancer_acrs_gr,
    genome = "hg38",
    universe = all_acrs_gr,
    ntimes = 1000,
    alternative = "greater"
  )
  data.frame(TF = tf, observed = pt$numOverlaps$observed, expected = mean(pt$numOverlaps$permuted),
             z_score = pt$numOverlaps$zscore, p_value = pt$numOverlaps$pval)
}, future.seed = TRUE)
plan(sequential)

print("Permutation Test Results:"); print(bind_rows(perm_results))
